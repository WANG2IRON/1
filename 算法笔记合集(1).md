# ACM算法笔记


## 目录


- [数学](#数学)

  - [六边形面积](#六边形面积)

  - [成绩统计](#成绩统计)

  - [字符串转换](#字符串转换)

  - [骰子期望次数](#骰子期望次数)

  - [牛牛吃饭期望](#牛牛吃饭期望)

  - [三角形判断](#三角形判断)

  - [发射火箭](#发射火箭)

  - [函数 f(x)=lowbit(x) 的求和](#函数-fxlowbitx-的求和)

  - [墙壁划线](#墙壁划线)

  - [最多质数和](#最多质数和)

  - [最大异或数](#最大异或数)

  - [最小质因数](#最小质因数)

  - [被三整除子串](#被三整除子串)

  - [X与Y的对数](#X与Y的对数)

  - [计算工资](#计算工资)

  - [发短信](#发短信)

  - [减 2 的 n 次幂](#减-2-的-n-次幂)

  - [最小权值和](#最小权值和)

  - [异或找缺失数](#异或找缺失数)

  - [好数的异或和](#好数的异或和)

- [栈](#栈)

  - [括号调整次数](#括号调整次数)

  - [前缀串长度](#前缀串长度)

  - [括号有效性](#括号有效性)

  - [合法字符串](#合法字符串)

- [队列](#队列)

  - [字符串加减 1](#字符串加减-1)

- [树](#树)

  - [最小操作树](#最小操作树)

  - [树子节点颜色个数](#树子节点颜色个数)

- [图](#图)

  - [格子染色](#格子染色)

  - [打僵尸](#打僵尸)

  - [好格子](#好格子)

  - [棋子移动](#棋子移动)

  - [多叉树](#多叉树)

- [动态规划](#动态规划)

  - [括号期望](#括号期望)

  - [迷宫寻宝](#迷宫寻宝)

  - [随机加减](#随机加减)

  - [打地鼠](#打地鼠)

  - [包粽子](#包粽子)

- [贪心](#贪心)

  - [01 字符串交换次数](#01-字符串交换次数)

  - [加减 1 次数](#加减-1-次数)

  - [加减 1 相等](#加减-1-相等)

  - [加减 1 均值](#加减-1-均值)

  - [大胃王比赛](#大胃王比赛)

  - [炸弹](#炸弹)

  - [买花](#买花)

  - [买文具](#买文具)

  - [包车](#包车)

  - [对答案](#对答案)

  - [分苹果](#分苹果)

  - [蛇吃水果](#蛇吃水果)

  - [k 个子序列极差和最大](#k-个子序列极差和最大)

  - [物品价值](#物品价值)

  - [最大非零子数组](#最大非零子数组)

  - [最大正方形边长](#最大正方形边长)

  - [游戏嘲笑子数组](#游戏嘲笑子数组)

  - [密码锁拨动次数](#密码锁拨动次数)

  - [商品折扣](#商品折扣)

  - [打枪](#打枪)

  - [商店购物](#商店购物)

  - [字符串的权值](#字符串的权值)

  - [学生分组](#学生分组)

  - [打印次数](#打印次数)

  - [有效卡片](#有效卡片)

  - [病毒](#病毒)

- [回溯](#回溯)

  - [字符串插入加号](#字符串插入加号)

- [字符串](#字符串)

  - [01 字符串计数](#01-字符串计数)

  - [字符串拼接](#字符串拼接)

  - [密文解密](#密文解密)

  - [删除公共字符](#删除公共字符)

  - [字符串表达式](#字符串表达式)

  - [数字位整除个数](#数字位整除个数)

  - [查找敏感词](#查找敏感词)

  - [字母和](#字母和)

  - [红黑数之和](#红黑数之和)

  - [连续反转字符串](#连续反转字符串)

  - [相同子串个数](#相同子串个数)

  - [子串最小代价](#子串最小代价)

  - [大小写翻转](#大小写翻转)

- [数组](#数组)

  - [数组加 1](#数组加-1)

  - [游戏记录](#游戏记录)

  - [非递减数组](#非递减数组)

  - [完美集合](#完美集合)

  - [子数组除法](#子数组除法)

  - [数组相减相等](#数组相减相等)

- [排序](#排序)

  - [字典序最大序列](#字典序最大序列)

  - [最少交换次数](#最少交换次数)

  - [数组删除](#数组删除)

  - [数组模排序](#数组模排序)

  - [分数排序](#分数排序)

- [双指针](#双指针)

  - [字符串统计](#字符串统计)

  - [对称数组](#对称数组)

- [模拟](#模拟)

  - [打印里字](#打印里字)

  - [贪吃蛇](#贪吃蛇)

  - [01 字符串截取](#01-字符串截取)

- [分治](#分治)

  - [池化](#池化)


## 统计信息


- 总分类数: 14

- 总题目数: 94


<a id="数学"></a>

## 数学


<a id="六边形面积"></a>

### 六边形面积


[原题-正六边形阴影面积计算](https://blog.csdn.net/ouyang_peng/article/details/150503972)

知识点：数学（分隔6个三角形）***

正六边形每个点代表运动员某个维度的分值。中心点代表0，顶点代表100。现在给定一个数组，代表每个维度的分值，以及一个长度L，代表中心点到顶点的实际长度，求阴影部分（代表运动员维度范围）的面积。要求输出误差小于1e-6。

输入：  
74 77 79 78 76 79
100
输出：  
15467.646724


#### 题解


##### 解法1: Python


```python

""" 
@brief 数学
"""

import sys
import math

def main():
    # input
    data = sys.stdin.read().splitlines()
    scores = list(map(float, data[0].split()))
    L = float(data[1])
        
    # solve
    area = 0.0
    for i in range(6):
        j = (i + 1) % 6
        area += 0.5 * (scores[i]*L/100) * (scores[j]*L/100) * math.sin(math.pi / 3)
    
    # output
    print(f"{area:.6f}")

if __name__ == "__main__":
    main()

```


---


<a id="成绩统计"></a>

### 成绩统计


知识点：数学*****6

输入 n 门课程分数，求这 n 个数的中位数、平均数、去极值平均数平均数（结果向下取整），指定对应的 a, b, c 三个指标，如果这三个指标任意满足一个（比如中位数≥a，或平均数≥b，或去极值平均数≥c）就输出 "Yes"。

示例 1：
3
100 80 60
10 20 30
输出：
Yes

示例 2：
输入：
3
10 20 30
35 25 25
输出：
No


#### 题解


##### 解法1: Python


```python

"""
@brief 数学
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    arr = list(map(int, data[1].split()))
    a, b, c =  map(int, data[2].split())

    score = sorted(arr)
    mid = n // 2
    median = score[mid] if n % 2 else (score[mid-1] + score[mid]) / 2
    mean = sum(score) // n
    trimmed = sum(score[1:-1]) / (n-2) if n > 2 else 0
    if  median >= a or mean >= b or trimmed >= c:
        result = "Yes"
    else:
        result = "No"
    
    print(result)

if __name__ == "__main__":
    main()

```


---


<a id="字符串转换"></a>

### 字符串转换


[参考-字符串按索引转换](https://blog.csdn.net/ouyang_peng/article/details/150474857)

知识点：枚举、二进制

给定一个字符串，根据每个字符索引值的二进制表示中 1 的个数奇偶性来决定是否转换大小写：
如果索引的二进制表示中 1 的个数为偶数（包括 0），则将该字符转换为大写
如果索引的二进制表示中 1 的个数为奇数，则保持字符不变

输入格式
一个字符串（大小写字母组成）
输出格式
转换后的字符串

示例 1：
输入：
abcde
输出：
ABcDe


#### 题解


##### 解法1: Python


```python

""" 
@brief 数学
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    s = data[0].strip()
    
    result = []
    for i, char in enumerate(s):
        count = bin(i).count('1')
        if count % 2 == 0:
            result.append(char.upper())
        else:
            result.append(char)
    
    print(''.join(result))

if __name__ == "__main__":
    main()

```


---


<a id="骰子期望次数"></a>

### 骰子期望次数


知识点：数学****18

有一个 N 面的骰子，投掷 2 次（连续投掷两次视为一次试验），希望两次结果分别为 X 和 Y（X ≠ Y）。求得到目标结果所需的期望试验次数。保留小数点后一位。

示例 1：  
输入：  
2 1 2  
1 2  
说明：第一行 N=2，X=1，Y=2；第二行输入骰子每面的数字
输出：  
4.0  

示例 2：  
输入：  
5 1 2  
1 2 2 2 3  
输出：  
8.3


#### 题解


##### 解法1: Python


```python

"""
@brief 数学
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n, X, Y = map(int, data[0].split())
    a = list(map(int, data[1].split()))
    
    px = a.count(X) / n
    py = a.count(Y) / n
    result = 1.0 / (px * py)
    
    # output
    print(f"{result:.1f}")

if __name__ == "__main__":
    main()

```


---


<a id="牛牛吃饭期望"></a>

### 牛牛吃饭期望


知识点：数学****5

牛牛第 1 天吃了 1 碗，第 2 天吃了 2 碗，第 i 天吃的碗数是前面任意 j、k 天（j、k 独立且概率相等）的和，求每一天吃的碗数的期望

第一行输入总天数 n  
接下来每行输入第 i 天
输出对应输入第 i 天可能吃的碗数

示例 1：
输入：
3
1
2
5
输出：
1
2
5


#### 题解


##### 解法1: Python


```python

"""
@brief 数学
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    day = [int(data[i]) for i in range(1, n+1)]
    
    # solve
    for i in range(n):
        print(day[i])

if __name__ == "__main__":
    main()

```


---


<a id="三角形判断"></a>

### 三角形判断


知识点：数学***

[类似-不可能三角](https://www.nowcoder.com/discuss/750016145939247104?sourceSSR=post)

给定 a, b, c 分别代表三角形的三条边，输入 x, y, z 三个数作为三角形边长，判断能否组成三角形，不能则输出 "can not"；如果能，组成的三角形与a, b, c 组成的三角形相似，则输出 "similar",否则，输出 "can,but not similar"。

判断输入的多个正整数数组能否构成三角形，以及与给定三角形是否相似。  
输入：  
第一行输入一个数组，代表基底三角形，输入保证是合法三角形  
第二行输入一个数字，代表即将要输入n行数组，每个数组长度为 3  
接下来输入n个数组...  
输出：  
对每组输入数组，首先判断数组能否构成三角形，如果能，接着判断是否与基底三角形相似，然后根据情况，每组判断后分别输出：("Similar"、"Can form a triangle but not similar"、"Can not form a triangle")

示例 1：
输入：
3 4 5
3
6 8 10
1 3 3
1 2 3
输出：
Similar
Can form a triangle but not similar
Can not form a triangle


#### 题解


##### 解法1: Python


```python

""" 
@brief 数学
"""

import sys

def is_triangle(sides):
    a, b, c = sorted(sides)

    return a + b > c

def is_similar(base, sides):
    a = sorted(base)
    b = sorted(sides)

    return (a[0] * b[1] == a[1] * b[0] and a[0] * b[2] == a[2] * b[0] and a[1] * b[2] == a[2] * b[1])

def main():
    # input
    data = sys.stdin.read().splitlines()
    base = list(map(int, data[0].split()))
    n = int(data[1])
    test = [list(map(int, data[i].split())) for i in range(2, n+2)]
    
    # solve
    for sides in test:
        if not is_triangle(sides):
            print("Can not form a triangle")
        elif is_similar(base, sides):
            print("Similar")
        else:
            print("Can form a triangle but not similar")

if __name__ == "__main__":
    main()

```


---


<a id="发射火箭"></a>

### 发射火箭


知识点：数学（困难）****7

发射火箭（火箭初始在地球内，速度不为 0），地球半径为 R，球心坐标为（0, 0, 0），发射点坐标为 x, y, z，火箭三个坐标向的速度为 vx, vy, vz，请问火箭飞出大气层的时刻，输入 t 组，每组一行，每行输入分别为 x, y, z, vx, vy, vz, R，每行输出为一个时刻

示例 1：
输入：
1
0 0 0 1 0 0 10
输出：
10.00


#### 题解


##### 解法1: Python


```python

import sys
import math

def main():
    # input
    data = sys.stdin.read().splitlines()
    t = int(data[0])
    array = [list(map(float, data[i].split())) for i in range(1, t+1)]

    for i in range(t):
        x, y, z, vx, vy, vz, R = array[i]
        a = vx*vx + vy*vy + vz*vz
        b = 2*(x*vx + y*vy + z*vz)
        c = x*x + y*y + z*z - R*R
        delta = b*b - 4*a*c

        if delta < 0:
            result = 0
        else:
            t1 = (-b + math.sqrt(delta)) / (2*a)
            t2 = (-b - math.sqrt(delta)) / (2*a)
            if t1 > 0 and t2 > 0:
                result = min(t1, t2)
            elif t1 > 0:
                result = t1
            elif t2 > 0:
                result = t2
            else:
                result = 0

        print(f"{result:.2f}")

if __name__ == "__main__":
    main()

```


---


<a id="函数-fxlowbitx-的求和"></a>

### 函数 f(x)=lowbit(x) 的求和


知识点：位运算、模拟

小红定义函数 f(x) 为 x 二进制数的最低位 1 对应的数，比如 10(1010) 对应的数为 2，12(1100) 对应的数为 4。输入整数 n，输出 i/f(i) [1<=i<=n] 的加和
输入：正整数 n
输出：i/f(i) [1<=i<=n] 的加和

示例 1：
输入：
1
2
3
5
8
输出：
1
2
5
11
22


#### 题解


##### 解法1: Python


```python

""" 
@brief 位运算
"""

import sys

def main():
    # read
    n = int(sys.stdin.readline().strip())
    
    # solve
    total = 0
    for i in range(1, n + 1):
        fx = i & -i
        total += i // fx
    
    print(total)

if __name__ == "__main__":
    main()

```


---


<a id="墙壁划线"></a>

### 墙壁划线


知识点：数学（困难）***

[原题-墙壁划线](https://www.nowcoder.com/practice/fbae28533ca04bd0ba088329cb46210d)

计算a*b大小的砖砌成的横X块,竖Y块构成的墙面，从左上角到右下角的对角线以及右上角到左下角的对角线一共穿越了多少次砖的边界
输入：a,b,x,y
输出：sum(左对角线经过每条砖缝与+右对角线经过每条砖缝)


#### 题解


##### 解法1: Python


```python

""" 
@brief 数学
"""

import math

def main():
    data = input().split()
    a, b, x, y = map(int, data)
    d = math.gcd(a, b)
    line_points = a + b + 1 - d
    total_points = 2 * line_points
    if a % 2 == 0 or b % 2 == 0:
        total_points -= 1
    print(total_points)

if __name__ == '__main__':
    main()

```


---


<a id="最多质数和"></a>

### 最多质数和


知识点：贪心、数学***

给定一个大于等于2的整数，求最多能有多少个质数求和得到该数。（质数可以重复）

示例 1：
输入：
2
输出：
1

示例 1：
输入：
5
输出：
2
说明：5=2+3


#### 题解


##### 解法1: Python


```python

"""
@brief 数学

偶数全部2相加，奇数减1变成偶数，最后一个2，变为3
"""
def main():
    # read
    n = int(input())
    
    # solve
    if n % 2 == 0:
        print(n // 2)
    else:
        print((n - 1) // 2)

if __name__ == "__main__":
    main()

```


---


<a id="最大异或数"></a>

### 最大异或数


知识点：贪心、位运算****11

给定两个正整数 x, k，找到一个不大于 k 的正整数 y，使得 x ors y 最大。  
ors 定义： x 按位异或 y。

示例 1：  
输入  
6  
3 2  
5 4  
10 18  
0 5  
1 1  
7 4  
说明：第一行输入组数；后面每行为对应的 x 和 k
输出：  
1
2
17
5
1
1


#### 题解


##### 解法1: Python


```python

"""
@brief 位运算
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    t = int(data[0])
    a = [list(map(int, data[i].split())) for i in range(1, t+1)]
    
    for i in range(t):
        x, k = a[i]
        y = 0
        for j in range(31, -1, -1):
            x_bit = (x >> j) & 1
            desired = 1 - x_bit
            if (y | (desired << j)) <= k:
                y |= desired << j
        if y == 0:
            y = 1
        print(y)

if __name__ == "__main__":
    main()

```


---


<a id="最小质因数"></a>

### 最小质因数


知识点：数学

输入四个正整数，求他们的最小公约数（要求输出值大于1），如果没有则返回 -1

示例 1：
输入：
12 18 24 30
9 15 21 33
2 3 5 7
7 7 7 7
8 12 20 28
1 2 3 4
1000000007 1000000007 1000000007 1000000007
999999999 999999999 999999999 999999999
输出：
2
3
-1
7
2
-1
1000000007
3


#### 题解


##### 解法1: Python


```python

"""
@brief 数学
"""

import sys

def my_gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def main():
    # read
    data = sys.stdin.read().split()
    a, b, c, d = map(int, data)
    
    # solve
    gcd = my_gcd(my_gcd(a, b), my_gcd(c, d))

    if gcd == 1:
        print(-1)
        return
    
    for i in range(2, int(gcd**0.5) + 1):
        if gcd % i == 0:
            print(i)
            return

    print(gcd)

if __name__ == "__main__":
    main()

```


---


<a id="被三整除子串"></a>

### 被三整除子串


知识点：数论(困难)（一个数能被3整除，当且仅当它的各位数字之和能被3整除）、贪心***

[参考-形成三的最大倍数](https://leetcode.cn/problems/largest-multiple-of-three)

计算一个数字字符串能被三整除的最大字符串子串（值最大第一，若多个串相等，取长的字符串）

示例 1：  
输入：
4
819  
86710
1
000000
输出：  
981
8760

0


#### 题解


##### 解法1: Python


```python

"""
@brief 数学
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    s = [data[i].strip() for i in range(1, n+1)]

    def remove_one(count, candidates):
        for digit in candidates:
            if count[digit] > 0:
                count[digit] -= 1
                return True
        return False
    
    def remove_two(count, candidates):
        removed = 0
        for digit in candidates:
            while count[digit] > 0 and removed < 2:
                count[digit] -= 1
                removed += 1
            if removed == 2:
                return True
        return False
    
    def build_result(count):
        result_chars = []
        for digit in range(9, -1, -1):
            result_chars.append(str(digit) * count[digit])
        return ''.join(result_chars)

    def solve(s):
        count = [0] * 10
        digits = [int(char) for char in s]
        total_sum = sum(digits)
        for d in digits:
            count[d] += 1
        
        remainder = total_sum % 3
        if remainder == 1:
            if not remove_one(count, [1, 4, 7]):
                if not remove_two(count, [2, 5, 8]):
                    return ""
        elif remainder == 2:
            if not remove_one(count, [2, 5, 8]):
                if not remove_two(count, [1, 4, 7]):
                    return ""

        result = build_result(count)

        if result and result[0] == '0':
            return "0"
        
        return result
    
    for i in range(n):
        print(solve(s[i]))

if __name__ == "__main__":
    main()

```


---


<a id="X与Y的对数"></a>

### X与Y的对数


[参考-X与Y的对数](https://blog.csdn.net/szm20040704/article/details/147619389)

知识点：位运算、双指针*****22

已知非负整数 A, B，求有多少组 X, Y，满足 X 与 Y = A, X 或 Y = B, X <= Y

示例 1
输入：  
4 7  
输出：  
2  

示例 2  
输入：  
0 15
输出：  
8


#### 题解


##### 解法1: Python


```python

"""
@brief 位运算

X + Y = X OR Y + X AND Y = A + B
A <= X <= Y <= B
"""
import sys

def main():
    data = sys.stdin.read().splitlines()
    A, B = map(int, data[0].split())

    count = 0
    i, j = A, B
    while i <= j:
        if i & j == A and i | j == B:
            count +=1
        i += 1
        j -= 1
    
    print(count)

if __name__ == '__main__':
    main()

```


---


<a id="计算工资"></a>

### 计算工资


知识点：数学****26

第一个月工资 a 元，每个月工资递增 b 元，求第 n 个月的时候，工资总和。

示例 1：
输入：
1000 100 12
输出：
18600


#### 题解


##### 解法1: Python


```python

"""
@brief 数学
"""

def main():
    a, b, n = map(int, input().split())
    
    total = 0
    for i in range(1, n + 1):
        total += a + (i - 1) * b
    #  total = n * a +  n * (n - 1) * b // 2
    
    print(total)

if __name__ == "__main__":
    main()

```


---


<a id="发短信"></a>

### 发短信


[参考-发短信](https://wenku.csdn.net/answer/424px4gudf)

知识点：数学

牛牛所在的学校进行了期末考试，一共有 n 个人参加考试，考试共有 m 门科目。老师想给在至少一门考试中成绩超过平均成绩的学生发祝福消息，请你计算需要发送祝福消息的学生人数。

输入描述
在一行上输入两个整数 $n, m (1 \le n \le 10000; 1 \le m \le 100)$。此后 m 行，每行输入 n 个整数 $a_{j1}, a_{j2}, \cdots, a_{jn} (0 \le a_{ji} \le 100)$ 表示第 j 门考试中第 i 个学生的成绩。

输出描述
输出一个整数，表示需要发送祝福消息的学生人数。

示例 1：  
输入：  
3 2
80 90 70
60 70 80
输出：  
2


#### 题解


##### 解法1: Python


```python

"""
@brief 数学
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n, m = map(int, data[0].split())
    scores = [list(map(int, data[i].split())) for i in range(1, m+1)]
    
    bless = [0] * n

    for j in range(m):
        avg = sum(scores[j])/n
        for i in range(n):
            if scores[j][i] > avg:
                bless[i] = 1

    print(sum(bless))

if __name__ == "__main__":
    main()

```


---


<a id="减-2-的-n-次幂"></a>

### 减 2 的 n 次幂


[参考-减 2 的 n 次幂](https://www.cnblogs.com/zhaojiayu/p/18994827)

知识点：贪心、位运算（困难）****4

给定一个数组，每次操作可以选择一个或多个元素，减去 2 的 n 次，最少需要多少次操作才能将所有元素变为 0？

示例 1：
输入：
1 2 3 4
输出：
3


#### 题解


##### 解法1: Python


```python

"""
@brief 位运算
"""

def min_op(a):
    bit_or = 0
    for num in a:
        bit_or |= num

    count = 0
    # count = bin(bit_or).count('1')
    while bit_or:
        count += bit_or & 1
        bit_or >>= 1

    return count

def main():
    # input
    a = list(map(int, input().split()))
    
    result = min_op(a)
    print(result)

if __name__ == "__main__":
    main()

```


---


<a id="最小权值和"></a>

### 最小权值和


知识点：数学*****23

输入一个共 3 个数的数组，第一个数的权值为 0，后面每个数的权值为当前数与前一个数作差的绝对值，三个数的顺序可以打乱，求这个数组权值和的最小值。

示例 1
输入：
5 5 11
输出：
6


#### 题解


##### 解法1: Python


```python

"""
@brief 数学
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    arr = list(map(int, data[0].split()))

    result = max(arr) - min(arr)
    
    print(result)

if __name__ == "__main__":
    main()

```


---


<a id="异或找缺失数"></a>

### 异或找缺失数


知识点：位运算

存在一个数组，该数组中元素为从 1 到 n 的整数，互不重复，已知该数据的长度 n 和在缺少某个元素时的数组剩余元素的异或和，希望得到该数组缺失的元素。

输入：第一行为用例个数，之后第一行为第一个用例，包含两个数n,k，n表示整数，k表示为当前异或和  
输出：缺失的整数  

示例 1：  
输入：  
3
5 2
10 14
3 0 
输出：  
3
5
0


#### 题解


##### 解法1: Python


```python

""" 
@brief 数学
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    t = int(data[0])
    n = [int(data[i].split()[0]) for i in range(1, t+1)]
    k = [int(data[i].split()[1]) for i in range(1, t+1)]

    for i in range(t):
        # fast xor
        def fast_xor(n):
            mod = n & 3 # mod = n % 4
            if mod == 0:
                return n
            elif mod == 1:
                return 1
            elif mod == 2:
                return n + 1
            else:
                return 0
        # total_xor = 0
        # for j in range(1, n[i] + 1):
        #     total_xor ^= j
        missing = fast_xor(n[i]) ^ k[i]
      
        print(missing)

if __name__ == "__main__":
    main()

```


---


<a id="好数的异或和"></a>

### 好数的异或和


知识点：位运算***

一个数的二进制中 "1" 的个数为偶数，则为好数，输入 n 个元素的数组，输出其中好数的异或和。

示例 1：
输入：
4
3 5 7 9
输出：
15


#### 题解


##### 解法1: Python


```python

""" 
@brief 数学
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    arr = list(map(int, data[1].split()))
    
    xor = 0
    for num in arr:
        # count = bin(num).count('1')
        count = 0
        temp = num
        while temp:
            count += temp & 1
            temp >>= 1
        if count % 2 == 0: 
            xor ^= num 
            
    print(xor)

if __name__ == "__main__":
    main()

```


---


<a id="栈"></a>

## 栈


<a id="括号调整次数"></a>

### 括号调整次数


知识点：栈、贪心***

给定 2 个只包括 '('，')'，'{'，'}'，'[', ']' 的字符串 s ，判断经过几次调整字符串把它变成有效。  
有效字符串需满足：  
左括号必须用相同类型的右括号闭合。  
左括号必须以正确的顺序闭合。  
每个右括号都有一个对应的相同类型的左括号  

示例 1：
4  
({[]])  
({[]]}  
(  
)  
输出：  
1  
2  
1  
1


#### 题解


##### 解法1: Python


```python

"""
@brief 栈

左括号：入栈
右括号：栈为空，计数+1；栈不为空，弹出栈顶，如果不匹配，计数+1
栈中剩余左括号没有匹配，计数+len(stack)
"""
import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    s = [data[i].strip() for i in range(1, n+1)]

    # stack
    def adjust(s):
        stack = []
        count = 0
        match = {'(': ')', '{': '}', '[': ']'}

        for char in s:
            if char in match:
                stack.append(char)
            else:
                if not stack:
                    count += 1
                    continue
                top = stack.pop()
                if match[top] != char:
                    count += 1
            
        count += len(stack)

        return count

    # output
    for string in s:
        print(adjust(string))

if __name__ == "__main__":
    main()

```


---


<a id="前缀串长度"></a>

### 前缀串长度


知识点：栈、贪心

"("、")" 组成的字符串，求这个字符串合法的最长前缀串长度。  
如："()"、"()()"、"(()())" 均为合法子串；")("、"(("、"))" 均为不合法子串。

示例 1：
7
()())
(()())
)(
()
(()
())()
((()))
输出：   
4
6
0
2
0
2
6


#### 题解


##### 解法1: Python


```python

""" 
@brief 栈
"""

def main():
    # input
    s = input().strip()
    
    stack = []
    max_len = 0
    
    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        else:
            if not stack:
                break
            stack.pop()
            if not stack:
                max_len = i + 1
    
    print(max_len)

if __name__ == "__main__":
    main()

```


##### 解法2: Python


```python

""" 
@brief 计数
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    s = [data[i].strip() for i in range(1, n+1)]
    
    # solve
    def valid_prefix(s):
        balance = 0
        max_len = 0
        
        for i, ch in enumerate(s):
            if ch == '(':
                balance += 1
            else:
                balance -= 1
            if balance < 0:
                break
            if balance == 0:
                max_len = i + 1
        
        return max_len

    # output
    for string in s:
        print(valid_prefix(string))

if __name__ == "__main__":
    main()

```


---


<a id="括号有效性"></a>

### 括号有效性


知识点：栈

[参考-有效的括号字符串](https://leetcode.cn/problems/valid-parenthesis-string/description/)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号
给定一个输入，输出是否有效

示例 1：
输入：
8
()
()[]{}
(]
([)]
{[]}
((()))
{[()]}
([)]
输出：
True
True
False
False
True
True
True
False


#### 题解


##### 解法1: Python


```python

"""
@brief 栈
"""

import sys

def is_valid(s: str) -> bool:
    stack = []
    mapping = {')': '(', ']': '[', '}': '{'}
    
    for char in s:
        if char in mapping.values():
            stack.append(char)
        elif char in mapping.keys():
            if not stack or stack[-1] != mapping[char]:
                return False
            stack.pop()
    
    return not stack

def main():
    # read
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    s = [data[i].strip() for i in range(1, n+1)]
    
    # output
    for string in s:
        result = is_valid(string)
        print(str(result))

if __name__ == "__main__":
    main()

```


---


<a id="合法字符串"></a>

### 合法字符串


知识点：贪心、栈****21

字符串（由 "a" "b" 构成）是否能够由 "ab" 通过任意位置插入构成，若能构成输出 "YES"，否则 "NO"。

示例 1：
输入：
ab
aabb
abab
ba
abb
aaab
输出：
YES
YES
YES
NO
NO
NO


#### 题解


##### 解法1: Python


```python

"""
@brief 栈
"""

def main():
    s = input().strip()

    count = 0
    for char in s:
        if char == 'a':
            count += 1
        elif char == 'b':
            count -= 1
            if count < 0:
                print("NO")
                return

    print("YES" if count == 0 else "NO")

if __name__ == "__main__":
    main()

```


---


<a id="队列"></a>

## 队列


<a id="字符串加减-1"></a>

### 字符串加减 1


知识点：枚举、滑动窗口、队列、双指针

[类似-字符串加减](https://ac.nowcoder.com/acm/contest/11214/I)

给定一个数字字符串 s，可以对每个数字做加 1 或减 1 的操作，现在给定整数 k，希望操作的次数尽可能少，使得操作之后，s 有一个长度为 k 的子串，子串里的所有数字相等。求最小操作次数。

示例 1：  
输入：  
5 3  
59283  
说明：第一行字符串长度 5，k=3；第二行字符串
输出：  
6  
说明：2->3 操作一次 +1，8->3 操作 5 次 -1，59333


#### 题解


##### 解法1: Python


```python

""" 
@brief 枚举
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n, k = list(map(int, data[0].split()))
    s = data[1].strip()
    
    # solve
    min_operations = float('inf')
    for i in range(n - k + 1):
        substring = s[i:i+k]
        for target in range(10):
            operations = 0
            for char in substring:
                operations += abs(int(char) - target)
            min_operations = min(min_operations, operations)
    
    # output
    print(min_operations)

if __name__ == "__main__":
    main()

```


##### 解法2: Python


```python

""" 
@brief 队列
"""

import sys
from collections import deque

def main():
    # input
    data = sys.stdin.read().splitlines()
    n, k = list(map(int, data[0].split()))
    s = data[1].strip()
    
    # solve
    min_operations = float('inf')
    for target in range(10):
        costs = [abs(int(char) - target) for char in s]
        window = deque()
        current_sum = 0
        for i in range(n):
            window.append(costs[i])
            current_sum += costs[i]
            if len(window) > k:
                current_sum -= window.popleft()
            if len(window) == k:
                min_operations = min(min_operations, current_sum)
    
    # output
    print(min_operations)

if __name__ == "__main__":
    main()

```


---


<a id="树"></a>

## 树


<a id="最小操作树"></a>

### 最小操作树


知识点：BFS、DFS、队列*****1

[参考-最小操作树](https://blog.csdn.net/DerrickKose/article/details/126885519)

给定一颗根为 1 号节点的数，每个节点初始权值为 1。现在每次可以选择一个节点，使其子树所有节点的权值加 1，最少多少次操作可以使得每个节点的权值等于其编号。  

第一行：树上节点数量 2≤n≤100000；  
接下来 n-1 行：u 号节点和 v 号节点间有一条边相连 1≤u,v≤n  
输出最小操作次数  

示例 1：  
输入：  
3    
1 2    
1 3     
输出：    
3  

示例 2：
输入：
5
1 2
1 3
2 4
2 5
输出：
8


#### 题解


##### 解法1: Python


```python

"""
@brief BFS
"""

import sys
from collections import defaultdict, deque

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    a = [tuple(map(int, data[i].split())) for i in range(1, n)]
    
    graph = [[] for _ in range(n+1)]
    for u, v in a:
        graph[u].append(v)
        graph[v].append(u)

    parent = [0] * (n+1)
    visited = [False] * (n+1)
    queue = deque([1])
    visited[1] = True
  
    while queue:
        node = queue.popleft()
        for neighbor in graph[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                parent[neighbor] = node
                queue.append(neighbor)
    
    total = 0
    for i in range(2, n+1):
        total += (i - parent[i])

    print(total)

if __name__ == "__main__":
    main()

```


##### 解法2: Python


```python

"""
@brief DFS
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    a = [tuple(map(int, data[i].split())) for i in range(1, n)]
    
    graph = [[v for u, v in a if i == u] + [u for u, v in a if i == v] for i in range(n+1)]
    parent = [0] * (n+1)
  
    def dfs(node, par):
        parent[node] = par
        for neighbor in graph[node]:
            if neighbor != par:
                dfs(neighbor, node)
    dfs(1, 0)
    
    total = sum(i - parent[i] for i in range(2, n+1))

    print(total)

if __name__ == "__main__":
    main()

```


---


<a id="树子节点颜色个数"></a>

### 树子节点颜色个数


[参考-字母树](https://www.nowcoder.com/discuss/395546774016991232)

知识点：树遍历、DFS、BFS****24

给定一棵有 n 个节点的树，节点用 1, 2, ..., n 编号。1 号节点为树的根节点，每个节点上有一个字符表示的标记，S 表示染色，W 表示未染色。求给定节点的子树中出现的染色节点数。  

第一行输入 n-1 个正整数，第 i 个整数表示第 i+1 号节点的父亲节点 
第二行输入一个长度为 n 字符串，如 'SWWWWSWWW'，表示节点 1 到节点 n 的染色状态，S 表示染色，W 表示未染色  
第三行输入一个数表示要查询的节点

示例 1：
1 1
SWW
3
输出：
0

示例 2：
输入：
1 2 1 2
SSWWS
2
输出：
2

示例 3：
输入：
1 1 2 3 4
SSWWSS
6
输出：
1


#### 题解


##### 解法1: Python


```python

"""
@brief BFS
"""

import sys
from collections import deque

def main():
    data = sys.stdin.read().splitlines()
    p = list(map(int, data[0].split()))
    color = list(data[1].strip())
    query = int(data[2].strip())

    n = len(p) + 1
    queue = deque([query])
    count = 0
    
    child = [[] for _ in range(n+1)]
    for i, parent in enumerate(p, start=2):
        child[parent].append(i)

    while queue:
        node = queue.popleft()
        if color[node-1] == 'S':
            count += 1
        for i in child[node]:
            queue.append(i)
        # queue.extend(child[node])
    
    print(count)

if __name__ == "__main__":
    main()

```


##### 解法2: Python


```python

"""
@brief DFS
"""

import sys

def main():
    data = sys.stdin.read().splitlines()
    p = list(map(int, data[0].split()))
    color = list(data[1].strip())
    query = int(data[2].strip())

    n = len(p) + 1
    
    child = [[] for _ in range(n+1)]
    for i, parent in enumerate(p, start=2):
        child[parent].append(i)

    def dfs(node):
        count = 1 if color[node-1] == 'S' else 0
        for c in child[node]:
            count += dfs(c)
        return count
    
    print(dfs(query))

if __name__ == "__main__":
    main()

```


---


<a id="图"></a>

## 图


<a id="格子染色"></a>

### 格子染色


知识点：图遍历、切比雪夫距离、贪心***

描述：  
小红有一个 2x2 的印章，要求不能相邻盖章（公共边或公共角均不可）以及重复盖章。现在小红忘记了自己的盖章顺序，给定一张盖完后的表格，帮助小红确认盖章是否规范。0 代表未盖章的格子，1 代表盖章后的格子

输入：  
第一行输入两个整数 x, y，代表表格的行与列  
接下来给出一张 x 行 y 列的表  

输出：  
表格规范输出 Yes，否则输出 No  

示例 1：  
输入：  
4 4  
1 1 0 0  
1 1 0 0  
0 0 1 1  
0 0 1 1  
输出：  
No  
解释：两个章存在相邻角

示例 2:  
输入：  
5 6  
1 1 0 0 0 0  
1 1 0 0 0 0  
0 0 0 1 1 0  
0 0 0 1 1 0  
0 0 0 0 0 0  
输出：  
Yes


#### 题解


##### 解法1: Python


```python

""" 
@brief 图遍历
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    x, y = map(int, data[0].split())
    grid = [list(map(int, line.split())) for line in data[1:1+x]]
    
    stamps = []
    covered = [[False] * y for _ in range(x)]
    
    # check 2x2
    for i in range(x-1):
        for j in range(y-1):
            if grid[i][j] == grid[i][j+1] == grid[i+1][j] == grid[i+1][j+1] == 1:
                stamps.append((i, j))
                for di, dj in [(0,0),(0,1),(1,0),(1,1)]:
                    covered[i+di][j+dj] = True
    
    # check 1
    for i in range(x):
        for j in range(y):
            if grid[i][j] == 1 and not covered[i][j]:
                print("No")
                return
    
    # check adjacent
    for i, (i1, j1) in enumerate(stamps):
        for i2, j2 in stamps[i+1:]:
            if abs(i1-i2) <= 2 and abs(j1-j2) <= 2:
                print("No")
                return
    
    print("Yes")

if __name__ == "__main__":
    main()

```


---


<a id="打僵尸"></a>

### 打僵尸


[参考-岛屿数量](https://www.nowcoder.com/practice/0c9664d1554e466aa107d899418e814e)
[参考-岛屿的最大面积](https://www.nowcoder.com/practice/5568943d3a08403f932a5e54ec3ece71)

知识点：BFS（队列）、DFS（递归、栈）***

描述：  
2200年就剩下了2个人，这2个人在大的电子显示器上关注僵尸的动态，城市分成了很多方格，如果相邻的2个方格都至少存在一个僵尸，那么就容易形成一大波僵尸潮，一发导弹可以打掉一个僵尸潮。会送入一个n*m的矩阵，里面每个数字代表了方格内的僵尸数量。问需要发射多少导弹，最大的一波僵尸潮是多少个。

示例 1：  
输入：  
3 3  
0 5 3  
1 0 2  
2 0 1  
输出：  
2 11


#### 题解


##### 解法1: Python


```python

"""
@brief DFS
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    if not data:
        return
    n, m = map(int, data[0].split())
    grid = []
    for i in range(1, n+1):
        row = list(map(int, data[i].split()))
        grid.append(row)
    
    # initial
    count = 0
    max_size = 0

    def dfs(i, j):
        if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] == 0:
            return 0
        
        total = grid[i][j]
        grid[i][j] = 0

        total += dfs(i + 1, j)
        total += dfs(i - 1, j)
        total += dfs(i, j + 1)
        total += dfs(i, j - 1)

        return total

    # traverse
    for i in range(n):
        for j in range(m):
            if grid[i][j] > 0:
                count += 1
                size = dfs(i, j)
                max_size = max(size, max_size)
    
    print(count, max_size)

if __name__  == "__main__":
    main()

```


##### 解法2: Python


```python

"""
@brief BFS
"""

import sys
from collections import deque

def main():
    # read
    data = sys.stdin.read().splitlines()
    if not data:
        return
    n, m = map(int, data[0].split())
    grid = []
    for i in range(1, n+1):
        row = list(map(int, data[i].split()))
        grid.append(row)
    
    # initial
    count = 0
    max_size = 0

    def bfs(i, j):
        queue = deque()
        queue.append((i, j))
        total = grid[i][j]
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        while queue:
            x, y = queue.popleft()
            grid[x][y] = 0
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] > 0:
                    queue.append((nx, ny))
                    total += grid[nx][ny]
                    grid[nx][ny] = 0

        return total

    # traverse
    for i in range(n):
        for j in range(m):
            if grid[i][j] > 0:
                count += 1
                size = bfs(i, j)
                max_size = max(size, max_size)
    
    print(count, max_size)

if __name__  == "__main__":
    main()

```


---


<a id="好格子"></a>

### 好格子


知识点：BFS****9

有红、蓝、空的格子（矩阵），红格子上下左右如果有蓝格子，则这个格子定义为好格子，求好格子数量

示例 1：
输入：
3 3
RBR
BRB
RBR
输出：
5


#### 题解


##### 解法1: Python


```python

"""
@brief BFS
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n, m = map(int, data[0].split())
    grid = [list(str(data[i].strip())) for i in range(1, n+1)]
    
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    count = 0
    
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 'R':
                for di, dj in directions:
                    ni, nj = i + di, j + dj
                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 'B':
                        count += 1
                        break

    print(count)

if __name__ == "__main__":
    main()

```


---


<a id="棋子移动"></a>

### 棋子移动


知识点：状态机***

有2019个方块，每个方块操作一次代表向右移动一次，每个棋子可以在一个位置停留，当棋子移动方向下一个位置被占用时不移动
第一行输入n，代表棋子个数
第二行输入n个数，代表从1-n号棋子每个棋子的初始位置（每个棋子初始位置不重复）
第三行输入m，代表操作次数
接下来m行，每行一个数字，代表操作的棋子编号
求最终n个棋子的位置
注意：棋子和棋盘的方格占用需要单独考虑。移动时需要注意棋盘的位置，棋子不能超出棋盘范围

示例 1：
输入：
3  
1 2 3  
5  
1  
2  
3  
1  
2  
输出：  
1 3 4  
说明：  
第一次操作，1 的下一个被 2 占用，不移动；
第二次操作，2 的下一个被 3 占用，不移动；
第三次操作，3 的下一个没被占用，移动到 4；
第四次操作，1 的下一个被 2 占用，不移动；
第五次操作，2 的下一个没被占用，移动到 3。


#### 题解


##### 解法1: Python


```python

""" 
@brief 状态机
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    positions = list(map(int, data[1].split()))
    m = int(data[2])
    operations = list(map(int, data[3:3 + m]))
    
    # initial
    SIZE = 2019
    occupied = [0] * (SIZE + 1)
    for pos in positions:
       occupied[pos] = 1
    
    # traverse
    for op in operations:
        current = op
        next = op + 1
        if 1 < next <= SIZE and occupied[current] == 1 and occupied[next] == 0:
            occupied[current] = 0
            occupied[next] = 1
    
    # output
    result = [str(i) for i in range(1, SIZE + 1) if occupied[i] == 1]
    print(" ".join(result))

if __name__ == "__main__":
    main()

```


---


<a id="多叉树"></a>

### 多叉树


知识点：DFS****3

[参考-路径总和2](https://leetcode.cn/problems/path-sum-ii/description/)

给你一颗多叉树，但是保证根节点是 1，给定每个节点的权值（一个数组），然后小美可以从根节点出发，在任意位置停下来（可以在叶子节点停，也可以中间停），给一个阈值 m，求所有的路径中，路径和小于 m 的最大值  

示例 1：
输入：
5 10
1 2 3 4 5
1 2
1 3
2 4
2 5
输出：
8


#### 题解


##### 解法1: Python


```python

"""
@brief DFS
"""

import sys

def main():
    data = sys.stdin.read().splitlines()
    n, m = map(int, data[0].split())
    values = list(map(int, data[1].split()))
    u = [int(data[i].split()[0]) for i in range(2, 1+n)]
    v = [int(data[i].split()[1])for i in range(2, 1+n)]
    
    tree = [[] for _ in range(n)]
    for i in range(n-1):
        tree[u[i]-1].append(v[i]-1)
    
    def dfs(node, current):
        current += values[node]
        max_sum = current if current < m else float('-inf')
        for child in tree[node]:
            max_sum = max(max_sum, dfs(child, current))
        
        return max_sum
    
    result = dfs(0, 0)
    print(result if result != float('-inf') else 0)

if __name__ == "__main__":
    main()

```


---


<a id="动态规划"></a>

## 动态规划


<a id="括号期望"></a>

### 括号期望


知识点：栈、动态规划（困难？概率、期望）

字符串包含 "(", ")", "?"。小红有魔法，把 "?" 变成 "(" 或 ")" 的概率分别是 50%。求组成匹配括号对数量的期望 E。

示例 1：
输入：
((?    
((??   
()?
?
??
???
????
输出：
0.500000
1.000000
1.000000
0.000000
0.250000
0.500000
0.812500
说明：
对于 "((?"，有 "((()"、"(()"，匹配括号对数量 1，概率 0.5，匹配括号对数量期望 E=1x0.50=0.50；
对于 "((??"，有 "(((("、"((()"、"(()("、"(())"，匹配括号对数量 1，概率 0.5，匹配括号对数量 2，概率 0.25，匹配括号对数量期望 E=1x0.50+2x0.25=1.00；
对于 "()?"，有 "()("、"())"，匹配括号对数量 1，概率 1.0，匹配括号对数量期望 E=1x1.00=1.00；


#### 题解


##### 解法1: Python


```python

"""
@brief DP
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    s = [data[i].strip() for i in range(1, n+1)]
    
    def solve(str):
        n = len(str)
        dp = [0.0] * (n + 2)
        for i in range(n - 1, -1, -1):
            new_dp = [0.0] * (n + 2)
            for j in range(i + 1):
                char = str[i]
                if char == '(':
                    new_dp[j] = dp[j + 1]
                elif char == ')':
                    new_dp[j] = (1.0 + dp[j - 1]) if j > 0 else dp[j]
                else:  # char == '?'
                    opt1 = dp[j + 1]
                    opt2 = (1.0 + dp[j - 1]) if j > 0 else dp[j]
                    new_dp[j] = 0.5 * opt1 + 0.5 * opt2
            dp = new_dp
        result = dp[0]        
        print(f"{result:.6f}")
    
    for i in range(n):
        solve(s[i])

if __name__ == "__main__":
    main()

```


---


<a id="迷宫寻宝"></a>

### 迷宫寻宝


[参考-迷宫寻宝](https://easylearn.baidu.com/edu-page/tiangong/questiondetail?id=1841471976841843814)

知识点：动态规划*****7

小红需要通过一个有 n 关的迷宫，每关有两个宝箱：左侧宝箱收益为 $a_i$，右侧宝箱收益为 $c_i$ (i = 1, 2, ..., n)。在第 i 关选择宝箱后进入下一关，但当 i>1 时，根据与前一关选择的位置是否相同，可能支付额外代价：
如果位置相同，无额外代价；
如果从左侧切换到右侧，支付代价 $b_{i−1}$；
如果从右侧切换到左侧，支付代价 $d_{i−1}$。
初始进入第 1 关无代价。收益和代价可能为负。求小红通过所有关卡后的最大总收益。

第一行输入 n，代表站点个数  
后面 n 行，每行输入 a, b, c, d 四个数。  
输出为走完所有迷宫站点后，最多的财宝数

示例 1
输入：
2
1 2 3 4
5 6 7 8
输出：
10

示例 2
输入：
3
10 5 20 5
15 10 25 10
30 15 40 15
输出：
85

示例 3
输入：
2
-5 2 3 1
4 3 -2 2
输出：
6


#### 题解


##### 解法1: Python


```python

"""
@brief DP
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    arr = [tuple(map(int, data[i].split())) for i in range(1, n + 1)]
    
    dp = [[0, 0] for _ in range(n)]
    dp[0][0] = arr[0][0]
    dp[0][1] = arr[0][2]
    for i in range(1, n):
        a, b, c, d = arr[i]
        prev_b, prev_d = arr[i-1][1], arr[i-1][3]
        dp[i][0] = max(dp[i-1][0] + a, dp[i-1][1] + a - prev_d)
        dp[i][1] = max(dp[i-1][0] + c - prev_b, dp[i-1][1] + c)

    # output
    print(max(dp[n-1][0], dp[n-1][1]))

if __name__ == "__main__":
    main()

```


---


<a id="随机加减"></a>

### 随机加减


[参考-添加括号](https://blog.csdn.net/zhuibushixi/article/details/109723983)

知识点：位运算、动态规划、DFS（困难）

n 个数，n-1 个加减号，与 m 差值最小的结果，输出结果与 m 之间的绝对值。  
n<=20，m 绝对值小于 2000，每个输入数绝对值小于 100  

示例 1：  
输入：  
10  
1 3 5 3 4  
说明：m = 10，输入数组为 [1, 3, 5, 3, 4]，  
输出：  
0  
说明： 1-3+5+3+4=10，abs(m-10)=0


#### 题解


##### 解法1: Python


```python

""" 
@brief DFS
"""

import sys

def main():
    data = sys.stdin.read().splitlines()
    m = int(data[0])
    nums = list(map(int, data[1].split()))
    n = len(nums)

    def dfs(index, current):
        if index == n:
            return abs(current - m)
        add = dfs(index+1, current + nums[index])
        sub = dfs(index+1, current - nums[index])

        return min(add, sub)
    
    result = dfs(1, nums[0])

    print(result)

if __name__ == "__main__":
    main()

```


---


<a id="打地鼠"></a>

### 打地鼠


[参考-[HNOI2004]打鼹鼠](https://ac.nowcoder.com/acm/problem/20035)

知识点：滑动窗口、动态规划（困难）****17

n x m 网格，小明起始位置为 (1,1)，有 k 个地鼠，第 i 个地鼠信息 (xi, yi, ti, si)，表示 ti 时刻在 (xi, yi) 位置，如果击中获得 si 分。  
规则：  
移动阶段：在 ti-1 结束, ti 之前，小明可以选择在网格向上下左右移动一格，或不移动。
锤击阶段：在 t 时刻，小明在 (i, j) 击中该位置的所有地鼠，获得相应的分数
请规划线路，使小明获得最高分数。  

示例 1：
输入：  
5 3 3  
1 2 1 1  
1 2 3 2  
3 2 2 1  
输出：
3

示例 2：
输入：
2 2 1
2 2 1 10
输出：
0

示例 3：
输入：
2 2 3
1 1 1 10
2 2 100 20
1 1 200 30
输出：
60


#### 题解


##### 解法1: Python


```python

"""
@brief DP
"""

import sys
from collections import defaultdict

def main():
    # input
    data = sys.stdin.read().splitlines()
    n, m, k = map(int, data[0].split())
    a = [list(map(int, data[i].split())) for i in range(1, k+1)]

    b = defaultdict(int)
    for i in range(k):
        x, y, t, s = a[i]
        b[(t, x, y)] += s
    c = [[x, y, t, s] for (t, x, y), s in b.items()]
    c.sort(key=lambda x: x[2])
    dp = [0] * len(c)
    max_dist = (n-1) + (m-1)
    count = 0
    left = 0

    for i in range(len(c)):
        xi, yi, ti, si = c[i]
        dp[i] = si if abs(xi - 1) + abs(yi - 1) <= ti else 0
        while left < i and ti - c[left][2] > max_dist:
            count = max(count, dp[left])
            left += 1
        if count > 0:
            dp[i]= max(count + si, dp[i])
        for j in range(i - 1, left - 1, -1):
            xj, yj, tj, sj = c[j]
            if abs(xi - xj) + abs(yi - yj) <= ti - tj and dp[j] > 0:
                dp[i] = max(dp[i], dp[j]+si)

    print(max(dp))

if __name__ == "__main__":
    main()

```


---


<a id="包粽子"></a>

### 包粽子


知识点：动态规划（困难）****15

[参考-包粽子](https://www.nowcoder.com/discuss/353156615647993856?sourceSSR=search)

包粽子, 四个数 n, m, c0, d0, 一共 n 克面粉, m 种馅料  
然后 m 行, 每行四个数ai, bi, ci, di, ai 表示一共多少克该种馅料，每个粽子包法, bi 克第 i 种馅料 + ci 克面粉, 收益di, 或者 c0 克面粉, 不包馅料, 收益 d0
求最大收益

示例 1：
输入：
10 2 2 1
4 2 2 5
6 2 2 3
输出：
19


#### 题解


##### 解法1: Python


```python

"""
@brief DP
"""

import sys

def main():
    data = sys.stdin.read().splitlines()
    n, m, c0, d0 = map(int, data[0].split())
    array = [list(map(int, data[i].split())) for i in range(1, m+1)]

    plan = []
    dp = [0] * (n + 1)

    # binary
    for i in range(m):
        a, b, c, d = array[i]
        max_count = min(a // b, n // c)
        k = 1
        while max_count > 0:
            count = min(k, max_count)
            plan.append((count * c, count * d))
            max_count -= count
            k <<= 1
    # unbounded
    for i in range(c0, n + 1):
        dp[i] = max(dp[i], dp[i - c0] + d0)
    # 0-1
    for cost, value in plan:
        for j in range(n, cost - 1, -1):
            dp[j] = max(dp[j], dp[j - cost] + value)

    print(dp[n])

if __name__ == "__main__":
    main()

```


---


<a id="贪心"></a>

## 贪心


<a id="01-字符串交换次数"></a>

### 01 字符串交换次数


[参考-01串相邻交换次数](https://blog.csdn.net/ouyang_peng/article/details/150473270)

知识点：逆序对、贪心（困难）

给定一个由 '0' 和 '1' 组成的字符串，每次操作可以交换相邻的两个字符。问变换到所有可能的目标串中，所需交换次数最多是多少？

示例 1：
输入：
01000
输出：
3
解释：
变换到 "00001" 需要 3 次交换（将中间的 '1' 逐步右移 3 次）
变换到 "10000" 需要 1 次交换
由于题目要求交换次数最多的目标串，故答案为 3。


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

def main():
    # input
    s = input().strip()
    n = len(s)

    positions = [i for i, ch in enumerate(s) if ch == '1']
    k = len(positions)
    left = sum(positions[i] - i for i in range(k))
    right = sum((n - k + i) - positions[i] for i in range(k))

    print(max(left, right))

if __name__ == "__main__":
    main()

```


---


<a id="加减-1-次数"></a>

### 加减 1 次数


知识点：贪心、哈希***

给一个由数字组成的数组 a，可以对数组 a 中的每个元素任意进行+1 、-1 或不执行操作，每个元素最多只允许操作一次，求操作后，出现次数最多的数字的出现次数。  

示例 1：
输入：
1 3 2 6 5
输出：
3


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

from collections import defaultdict

def main():
    nums = list(map(int, input().split()))

    count = defaultdict(int)
    
    for num in nums:
        count[num-1] += 1
        count[num] += 1
        count[num+1] += 1
    
    max_count = max(count.values())

    print(max_count)

if __name__ == "__main__":
    main()

```


---


<a id="加减-1-相等"></a>

### 加减 1 相等


知识点：贪心、哈希

有两个数组 a 和 b，其中数组元素个数都为 n，可以按照序列（i，j）对数组 a[i] 和 b[j] 同时加 1，请问至少执行多少次操作，才能使得数组a和b完全相等，如果无法使得两个数组相等，则输出 -1

输入：  
第一行输入数组元素个数 n；  
第二行输入 n 个整数，表示数组 a 中各个元素的具体值；  
第三行输入 n 个整数，表示数组 b 中各个元素的具体值；  

输出：操作次数

示例 1：
输入：  
4  
1 2 3 5  
1 2 4 4  
输出：  
1  
说明：(i=2，j=3)，表示对数组 a[2] 和数组 b[3] 分别加 1，使得数组 a 和 b 完全相等


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    a = list(map(int, data[1].split()))
    b = list(map(int, data[2].split()))
    if sum(a) != sum(b):
        print(-1)
        return
    
    # solve
    total = 0
    for i in range(n):
        total += max(b[i] - a[i], 0)
    
    # output
    print(total)

if __name__ == "__main__":
    main()

```


---


<a id="加减-1-均值"></a>

### 加减 1 均值


知识点：贪心

长度为 n 的数组，对其元素进行+1、-1操作，问最少要操作多少次后满足：数组均值为 m，数组最小值 >= k（m >= k）。

示例 1：
输入：
3 3 2
1 2 3
输出：
3


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n, m, k = list(map(int, data[0].split()))
    array = list(map(int, data[1].split()))

    # solve
    count = 0
    total = 0
    for num in array:
        count += max(k - num, 0)
        total += max(num, k)

    count += abs(total - n * m)
    
    # output
    print(count)

if __name__ == "__main__":
    main()

```


---


<a id="大胃王比赛"></a>

### 大胃王比赛


知识点：贪心

有三个输入，N 为餐品数量，M 为选手最大饭量，数组为 N 份餐对应的饱腹值，输出选手是否可以吃饱。

示例 1：
输入：  
4 3  
1 2 1 5  
说明：N=4，M=3，数组饱腹值 [1, 2, 1, 5]  
输出：  
Yes


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    N, M = list(map(int, data[0].split()))
    values = list(map(int, data[1].split()))
    
    # solve
    total = sum(values)
    if total >= M:
        print("Yes")
    else:
        print("No")

if __name__ == "__main__":
    main()

```


---


<a id="炸弹"></a>

### 炸弹


[参考-两数之和](https://leetcode.cn/problems/two-sum/)

知识点：贪心、哈希（困难）****10

有 n 个炸弹，每个炸弹上有一个数字，初始状态下所有的炸弹都是触发状态，按下会变成非触发状态，只有当两个炸弹处于触发状态时且两个炸弹的数字和为 k 时，会爆炸，牛牛需要以最少的按动次数，保证炸弹不会爆炸。

示例 1：  
输入：  
8 8  
5 3 5 7 1 6 8 9  
说明：第一行输入 n=8，k=8；第二行输入炸弹上数字 5 3 5 7 1 6 8 9
输出：  
2  
说明：[5 3] 和 [7 1] 会爆炸，将炸弹 3 或 5，炸弹 7 或 1，按成非触发状态，输出 2 次


#### 题解


##### 解法1: Python


```python

"""
@brief 贪心
"""

import sys
from collections import Counter

def main():
    # input
    data = sys.stdin.read().splitlines()
    n, k = map(int, data[0].split())
    a = list(map(int, data[1].split()))
    
    freq = Counter(a)
    used = set()
    count = 0
    for num in list(freq.keys()):
        if num in used:
            continue            
        comp = k - num
        if num == comp:
            count += freq[num] - 1
        elif comp in freq:
            count += min(freq[num], freq[comp])
            used.add(comp)
        used.add(num)
    
    # output
    print(count)

if __name__ == "__main__":
    main()

```


---


<a id="买花"></a>

### 买花


知识点：贪心、堆

[参考-买花](https://ouyangpeng.blog.csdn.net/article/details/150501793)

每个店只买 0 或奇数朵花，买到的花总数需要是奇数，求最多可以买到多少朵。

示例 1：
输入：
4  
1 10 8 3  
输出：
19  
说明：最多购买 (10-1) + (8-1) + 3 = 19


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    arr = list(map(int, data[1].split()))

    odd = []
    for x in arr:
        if x % 2 == 1:
            odd.append(x)
        else:
            odd.append(x - 1)
    
    total = sum(odd)
    if total % 2 == 1:
        print(total)
    else:
        print(total - min(odd))

if __name__ == "__main__":
    main()

```


---


<a id="买文具"></a>

### 买文具


知识点：贪心

给出 n 个店铺，每个店铺卖的文具个数、每个文具的单价，求 k 元最多可以买多少文具？

第一行给 n, k 两个数，分别代表店铺数量和 k 元  
接下来 n 行分别给出两个数，分别代表该店铺的文具总量和文具单价，如
1 2  
2 3  
1 1  
输出一个整数，表示能买到的最多的玩具。

示例 1：
输入：
3 10
1 2
2 3
1 1
输出：
4


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n, k = list(map(int, data[0].split()))
    shop = [tuple(map(int, data[i].split())) for i in range(1, n+1)]
    
    shop.sort(key=lambda x: x[1])
    total = 0
    remain = k
    
    for count, price in shop:
        max_buy = min(count, remain // price)
        total += max_buy
        remain -= max_buy * price

        if remain <= 0:
            break
    
    print(total)

if __name__ == "__main__":
    main()

```


---


<a id="包车"></a>

### 包车


[参考-无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/description/)

知识点：贪心****14

包车，[l, r] 区间如果没有人定，则包车成功。输入 T 组区间，按顺序判断是否可以包车，统计可以包车的区间数量。

示例 1：
输入：
5
1 3
2 4
5 6
6 7
3 5
输出：
2


#### 题解


##### 解法1: Python


```python

"""
@brief 贪心
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    T = int(data[0])
    a = [list(map(int, data[i].split())) for i in range(1, T+1)]
    
    selected = []
    count = 0
    for i in range(T):
        l, r = a[i]
        overlap = False
        for start, end in selected:
            if max(l, start) <= min(r, end):
                overlap = True
                break
        if not overlap:
            selected.append((l, r))
            count += 1
    
    print(count)

if __name__ == "__main__":
    main()

```


---


<a id="对答案"></a>

### 对答案


知识点：贪心

牛牛期末考试全部为选择题，且只有 A、B 两个选项，牛牛做题时直接蒙的答案，现在考试结束，牛牛拿到答案后，想知道如果之前蒙的答案全部相反，能不能获得更高的分数，不能获得更高分输出 "Oh Yes",可以则输出 "Oh No",一样则输出 "(O.O)"。
输入第一行为牛牛蒙的答案，第二行为正确答案。

示例 1：  
输入：  
AA  
AB  
输出：  
(O.O)


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    a = data[0].strip()
    b = data[1].strip()

    n = len(a)
    count = 0
    for i in range(n):
        if a[i] == b[i]:
            count += 1

    if count > n - count:
        print("Oh Yes")
    elif count < n - count:
        print("Oh No")
    else:
        print("(O.O)")

if __name__ == "__main__":
    main()

```


---


<a id="分苹果"></a>

### 分苹果


[参考-分苹果](https://blog.csdn.net/qq_74219059/article/details/146903914)

知识点：贪心、二分查找***

n 个小孩，每个小孩编号 1-n，m 个苹果，小明的编号是 k。每个小孩至少分到一个苹果，并且相邻的小孩分到的数目差距不能大于 1。求小明分到的最多苹果数目。（m>=n>1, n>=k>=1）

示例 1：
输入：
5 10 2
输出：
3

示例 2：
输入：
3 8 2
输出：
3


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

def main():
    # input
    n, m, k = list(map(int, input().split()))

    def check(x):
        total = x
        for i in range(1, k):
            total += max(1, x - i)
        for j in range(1, n - k + 1):
            total += max(1, x - j)

        return total <= m
    
    left, right = 1, m
    result = 1
    while left <= right:
        mid = (left + right) // 2
        if check(mid):
            result = mid
            left = mid + 1
        else:
            right = mid - 1
    
    print(result)

if __name__ == "__main__":
    main()

```


---


<a id="蛇吃水果"></a>

### 蛇吃水果


知识点：贪心*****12

蛇的初始长度为 L，每吃一颗水果长度 +1，有 n 颗水果，每颗高度为 hi，蛇可以吃到不高于自己长度的水果，问蛇最长多少。

示例 1：
输入：
4 5
10 5 8 6
输出：
7


#### 题解


##### 解法1: Python


```python

"""
@brief 贪心
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n, L = map(int, data[0].split())
    a = list(map(int, data[1].split()))
    
    a.sort()
    for h in a:
        if L < h:
            break
        L += 1
    
    # output
    print(L)

if __name__ == "__main__":
    main()

```


---


<a id="k-个子序列极差和最大"></a>

### k 个子序列极差和最大


知识点：贪心

一个长度为 n 的数组，划分为 k 个不相交的非空子序列，使得子序列的极差之和最大，求最大的极差值之和

示例 1：  
输入：  
5 3
1 2 3 4 5  
说明：n=5, k=3  
输出：  
6  
说明：[1,2,3,4,5] 可拆为{1,5}{2,4}{3} 返回 6


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n, k = map(int, data[0].split())
    arr = list(map(int, data[1].split()))
    
    # solve
    arr.sort()
    if 2 * k <= n:
        t = k
    else:
        t = n - k
    
    result = sum(arr[-t:]) - sum(arr[:t])
    
    # output
    print(result)

if __name__ == "__main__":
    main()

```


---


<a id="物品价值"></a>

### 物品价值


知识点：贪心

n 个元素的值 a1-an，含正整数、负整数，可以操作 k 次，每个值最多操作一次，使 ai 变成 ai*ai，后续 m 次询问，每次询问需要取 1 个物品，计算每次取出的最大价值和？

示例 1：  
输入：  
5 5 4
-3 -2 2 3 4  
说明：第一行 n=5，m=5，k=4；第二行为 n 个元素值 [-3, -2, 2, 3, 4]  
输出：  
16 25 34 38 40  
说明：问询 1, 2, 3, 4, 5 时，对应输出：16, 25, 34, 38, 40

示例 2：
输入：
5 5 4
-3 -2 2 3 4
输出：
100 102 101


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n, m, k = map(int, data[0].split())
    a = list(map(int, data[1].split()))
    
    gain = [(a[i] * a[i] - a[i], i) for i in range(n)]
    gain.sort(key=lambda x: x[0], reverse=True)
    
    for i in range(k):
        idx = gain[i][1]
        a[idx] = a[idx] * a[idx]
    
    a.sort(reverse=True)

    result = []
    current = 0
    for i in range(m):
        current += a[i]
        result.append(str(current))
    
    print(" ".join(result))

if __name__ == "__main__":
    main()

```


---


<a id="最大非零子数组"></a>

### 最大非零子数组


知识点：贪心

给定一个 N 个元素的数组，输出其中不包含 0 的子数组的最大长度。

示例 1：  
输入：  
6  
1 2 3 0 4 5  
说明：第一行输入一个 N，表示数组长度，第二行输入 N 个数字，表示数组内容  
输出：
3  
说明：不包含 0 的子数组有 [1, 2, 3] 和 [4, 5]，长度分别为 3 和 2，输出 3


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    arr = list(map(int, data[1].split()))
    
    max_len = 0
    current= 0
    for num in arr:
        if num != 0:
            current += 1
            max_len = max(max_len, current)
        else:
            current = 0
    
    print(max_len)

if __name__ == "__main__":
    main()

```


---


<a id="最大正方形边长"></a>

### 最大正方形边长


[参考-最大正方形边长](https://blog.csdn.net/qq_20091631/article/details/142135903)

知识点：贪心****19

有 n 个木板，每个木板宽度是 1，第 i 个木板的高度是 ai，输入一行数，分别代表 n 个木板的高度，将这些木板任意顺序竖起来排列，请问可以截取的正方形边长最大是多少。

示例 1：  
输入：
5
5 1 4 2 3  
输出：  
3

示例 2：  
输入：
10
1 1 1 1 2 1 1 1 1 1 
输出：  
1


#### 题解


##### 解法1: Python


```python

"""
@brief 贪心
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    a = list(map(int, data[1].split()))
    
    a.sort(reverse=True)
    count = 0

    for i in range(n):
        if a[i] >= i + 1:
            count = i + 1
        else:
            break
    
    # output
    print(count)

if __name__ == "__main__":
    main()

```


---


<a id="游戏嘲笑子数组"></a>

### 游戏嘲笑子数组


知识点：贪心

玩家 A 和玩家 B 玩某种游戏，两个数组分别记录玩家第 i 局之后的得分。如果玩家 A 增加的分比玩家 B 增加的分多，或减少的分少，可以嘲讽一次玩家 B，反之亦然。第一局不可嘲讽。 
求最长连续多少局内，没有玩家受到嘲讽。

示例 1：  
输入：
10 
8 7 9 3 1 3 5 8 7 10
1 0 2 1 0 2 4 7 6 10
输出：  
4


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    a = list(map(int, data[1].split()))
    b = list(map(int, data[2].split()))
    
    max_len = 1
    current = 1
    for i in range(n-1):
        if a[i + 1] - a[i] == b[i + 1] - b[i]:
            current += 1
            max_len = max(max_len, current)
        else:
            current = 0

    # output
    print(max_len)

if __name__ == "__main__":
    main()

```


---


<a id="密码锁拨动次数"></a>

### 密码锁拨动次数


知识点：贪心

[原题-小红的密码锁](https://blog.csdn.net/weixin_49496731/article/details/127215276)

输入两个四位数的整数，表示密码锁的状态，只能逆时针拨动（9->8->...->0->9）密码锁的每一位数字，要求至少拨动多少次，能够使状态 1 变成状态 2

示例 1：  
输入：  
9999  
8888  
输出：  
4  
说明：每一位波动一次，总共 4 次可由状态 1 变为状态 2


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    a = str(data[0].strip())
    b = str(data[1].strip())
    
    total = 0
    for i in range(4):
        total += (int(a[i]) - int(b[i])) % 10
    
    print(total)

if __name__ == "__main__":
    main()

```


---


<a id="商品折扣"></a>

### 商品折扣


知识点：贪心***

购买 n 个商品，价格为 xi，商家为促销提供了 n 个折扣 ai，每个折扣只能使用一次，如何使用折扣使花费最少。

输入：  
第一行输入商品数目 n
第二行输入商品的价格 a
第三行输入商品的折扣 b
输出：  
购买n个商品的最小金额（保留三位小数）


#### 题解


##### 解法1: Python


```python

"""
@brief 贪心
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    a = list(map(int, data[1].split()))
    b = list(map(float, data[2].split()))
    
    # initial
    total = 0.0
    a.sort(reverse=True)
    b.sort()
    
    # traverse
    for i in range(n):
        total += a[i] * b[i]
        
    # output
    print(f"{total:.3f}")

if __name__ == "__main__":
    main()

```


---


<a id="打枪"></a>

### 打枪


知识点：贪心****6

假设子弹数量不限。刚开始枪没有安装子弹，一个弹夹有 m 个子弹，安装弹夹需要 a 分钟，安装 1 个子弹 b 分钟，开一枪需要 1 分钟，求牛牛开 n 枪，最小多少分钟。

1 < n, m, a, b < 100000

示例 1：
输入：
10 5 10 1
10 5 1 10
输出：
20
12


#### 题解


##### 解法1: Python


```python

"""
@brief 贪心
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n, m, a, b = map(int, data[0].split())
    
    count = n // m
    remain = n % m
    cycle = min(a+m, m*(b+1))
    if remain > 0:
        remain = min(a+remain, remain*(b+1))
    else:
        remain = 0
    
    total = count * cycle + remain
    print(total)

if __name__ == "__main__":
    main()

```


---


<a id="商店购物"></a>

### 商店购物


知识点：贪心*****9

有 n 个商店，第 i 个商店的产品数量为 yi，价格为 xi，如果购买给定数量 m 个产品；输出总价最小的数值。

输入：  
第一行为商店个数 n 及购买个数 m  
接下来 n 行输入，每行两个整数 xi, yi  
输出  
购买 m 个商品所需的最小金额

示例 1：
输入：
3 10
5 3
2 5
3 4
输出：
27


#### 题解


##### 解法1: Python


```python

"""
@brief 贪心
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n, m = map(int, data[0].split())
    a = [tuple(map(int, data[i].split())) for i in range(1, n+1)]

    a.sort(key=lambda x: x[0])
    total = 0
    remain = m
    
    for price, count in a:
        if remain <= 0:
            break
        buy = min(count, remain)
        total += buy * price
        remain -= buy
    
    # output
    print(total)

if __name__ == "__main__":
    main()

```


---


<a id="字符串的权值"></a>

### 字符串的权值


[参考-字符串拆分若干个子串权值和](https://blog.csdn.net/weixin_58779667/article/details/154494999)
[参考-字符串拆分2个子串权值和](https://wenku.csdn.net/answer/4yht7v7c8a)

知识点：贪心、枚举（困难）

一个字符串的权值定义为 a-b,其中 a 定义为字符串中存在偶数个字符的个数，b 定义为字符串中存在奇数个字符的个数。输入一个字符串，可以任何位置分割成两个子串，求所有子串权值和的最大值。

示例 1：  
输入：  
eggff
a
aabb
abcabc
输出：  
1  
-1
2
3


#### 题解


##### 解法1: Python


```python

"""
@brief 贪心
"""

import sys

def calculate(s):
    freq = [0] * 26
    for char in s:
        freq[ord(char) - ord('a')] += 1
    even = sum(1 for count in freq if count > 0 and count % 2 == 0)
    odd = sum(1 for count in freq if count > 0 and count % 2 == 1)

    return even - odd

def main():
    data = sys.stdin.readline().splitlines()
    s = str(data[0].strip())
    n = len(s)

    max_weight = float('-inf')
    
    for i in range(n + 1):
        total = calculate(s[:i]) + calculate(s[i:])
        max_weight = max(max_weight, total)
    
    print(max_weight)

if __name__ == "__main__":
    main()

```


---


<a id="学生分组"></a>

### 学生分组


知识点：贪心、堆***

n 名学生参与测试，对所有学生按照如下要求进行重新排序分组：
1. 每组人数不超过三人
2. 三人组要求最高成绩与最低成绩差值小于 10
3. 两人组要求最高成绩与最低成绩差值小于 20
4. 一人组不做要求
输出 n 个学生最少分多少组。

输入：  
第一行 n  
第二行 n 个数代表 n 个学生的成绩


#### 题解


##### 解法1: Python


```python

"""
@brief 贪心
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    scores = list(map(int, data[1].split()))
    
    # sort
    scores.sort()
    
    count = 0
    i = 0
    while i < n:
        if i + 2 < n and scores[i + 2] - scores[i] <= 9:
            count += 1
            i += 3
        elif i + 1 < n and scores[i + 1] - scores[i] <= 19:
            count += 1
            i += 2
        else:
            count += 1
            i += 1
    
    # output
    print(count)

if __name__ == "__main__":
    main()

```


---


<a id="打印次数"></a>

### 打印次数


[参考-后缀子串字母统计](https://blog.csdn.net/ouyang_peng/article/details/150468869)

知识点：字符映射、贪心（困难）

给定小写字母字符串，对每个前缀子串s[0...i]，计算前缀子串的所有后缀子串中每个字母出现次数的总和。
输入描述 ：
小写字母字符串
输出描述 ：
前缀子串的所有后缀子串中个字母出现次数的总和
例如：abc
前缀子串'a'，后缀子串'a'，occur['a'] = 1;
前缀子串'abc'，后缀子串['abc', 'bc', 'c']，occur['a'] = 1, occur['b'] = 2, occur['c'] = 3;

输入：
abc  
输出：  
1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  
1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  
1 2 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  
输入：  
xyhx  
输出：  
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0
0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0
0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 2 0


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

def main():
    s = input().strip()

    counts = [0] * 26
    for i, ch in enumerate(s):
        counts[ord(ch) - ord('a')] += i + 1
        print(' '.join(map(str, counts)))

if __name__ == "__main__":
    main()

```


---


<a id="有效卡片"></a>

### 有效卡片


知识点：贪心*****13

卡片上红色格数大于绿色格数的就是有效卡片，现知道有个操作可以将绿色格子变成红色，每操作一次即为操作数 1，请问如果 m 个卡片中，最少能变成 m-1 个有效卡片的话，操作的最少数是多少。
第一行输入 n, m，其中 n 代表每个卡片有 2*n 的格数，m 代表有 m 行输入，即 m 个卡片；
后面 m 行，每行输入有两个数 a 和 b，分别代表卡片的红色格数和绿色格数。

示例 1：
输入：  
5 4  
3 7  
5 5  
0 10  
7 3  
输出：  
4  

示例 2
输入：
5 1
3 7
输出：
0


#### 题解


##### 解法1: Python


```python

"""
@brief 贪心
"""

import sys

def main():
    data = sys.stdin.read().splitlines()
    n, m = map(int, data[0].split())
    arr = [tuple(map(int, data[i].split())) for i in range(1, m+1)]
    
    total, max_cost = 0, 0
    for i in range(m):
        a, b = arr[i]
        current = 0 if a > b else (b - a) // 2 + 1
        total += current
        max_cost = max(max_cost, current)
    
    result = total - max_cost
    print(result)

if __name__ == "__main__":
    main()

```


---


<a id="病毒"></a>

### 病毒


知识点：贪心、数学***

有一个病毒初始体积 t = 1，第 i 秒体积增加 i 平方。例如 i = 2，第 2 秒时，体积增加 2 * 2 = 4，则第2秒时病毒的体积为：1 + 4 = 5。
人类开发了病毒解药，解药能杀死体积为 k 的病毒。
输入 k，要求输出一次性能杀死病毒的最大体积。
例如：
k = 3，则输出 1。说明：k = 3 说明解药最多一次性杀死体积为 3 的病毒，而病毒在第一秒时体积为 1，第二秒时体积为 5，因此只能选择在第一秒杀死病毒，因此一次性能杀死体积为 1 的病毒
k = 9，则输出 5。说明：k = 9 说明解药最多一次性杀死体积为 9 的病毒，而病毒在第一秒时体积为 1，第二秒时体积为 5，第三秒时体积为 14，因此必须选择在第二秒杀死病毒，因此一次性能杀死体积为 5 的病毒。

示例 1：
输入：
2
3
9
输出：
1
5


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    k = list(map(int, data[1:n+1]))

    def solve(k):
        max_volume = 1
        i = 2
        while True:
            current = 1 + i * i
            if current <= k:
                max_volume = current
                i += 1
            else:
                break
        return max_volume
    
    # output
    for i in range(n):
        print(solve(k[i]))

if __name__ == '__main__':
    main()

```


---


<a id="回溯"></a>

## 回溯


<a id="字符串插入加号"></a>

### 字符串插入加号


[参考-加号（Plus）](https://ac.nowcoder.com/acm/contest/3286/C)

知识点：位运算、DFS、回溯（困难）****8

有一个字符串，其中字符均为 '1'-'9' 的数字，现在可以在这个字符串中可以加任意的 '+' 号，使其成为一个公式。如 '123456' 可以变为 '1+23+456'。但是 '+123456'、'1++23456' 这种不可以。让这个公式的和为质数，有多少种可能（没有质数输出 0）？

示例 1：
输入：  
123
11
13
111
输出：  
0
2
1
1


#### 题解


##### 解法1: Python


```python

"""
@brief DFS
"""

import sys
import math

def is_prime(n):
    if n == 2:
        return True
    elif n < 2 or n % 2 == 0:
        return False
    
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return False
    return True

def dfs(s, start, current):
    n = len(s)
    if start == n:
        return 1 if is_prime(current) else 0
    
    count = 0
    for end in range(start+1, n+1):
        num = int(s[start:end])
        count += dfs(s, end, current+num)
    
    return count

def main():
    # input
    s = str(input().strip())
    
    result = dfs(s, 0, 0)
    print(result)

if __name__ == "__main__":
    main()

```


---


<a id="字符串"></a>

## 字符串


<a id="01-字符串计数"></a>

### 01 字符串计数


知识点：贪心*****16

输入一个长度为 n 的 01 字符串，要求输出一个长度为 n 的数组，要求数组的每一个元素等于字符串从第 1 个元素开始到当前位置上不等于当前位置字符的累计计数。

示例 1  
输入：
6
010101
输出：  
0 1 1 2 2 3  

示例 2:
输入：
4
1111
输出：
0 0 0 0


#### 题解


##### 解法1: Python


```python

"""
@brief 贪心
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    s = data[1].strip()
    
    result = []
    count0 = 0 
    count1 = 0
    for char in s:
        if char == '0':
            result.append(count1)
            count0 += 1
        else:
            result.append(count0)
            count1 += 1
    
    print(*result)

if __name__ == "__main__":
    main()

```


---


<a id="字符串拼接"></a>

### 字符串拼接


输入两行分别代表给定字符串数组 a, b，包含可见字符与空格。
第二个数组大小一定是偶数。要求将第二个数组的后半部分截断拼接到第一个数组后面。
需要保留所有字符。然后分行分别打印转换后的a, b。

示例 1：  
输入：  
abd  
asdfgg  
输出：  
abdfgg  
asd


#### 题解


##### 解法1: Python


```python

""" 
@brief 字符串
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    a = data[0]
    b = data[1]
    
    # solve
    mid = len(b) // 2
    
    # output
    print(a+b[mid:])
    print(b[:mid])

if __name__ == "__main__":
    main()

```


---


<a id="密文解密"></a>

### 密文解密


知识点：字符串*****18

小明收到一串只包含小写字母的密文，解密的规则如下：
如果字符是元音字母 ("a"、e"、"i"、"o"、"u")，则不作任何改变。
如果字符是辅音字母，则将其替换为以下连续的三个字母：
第一位为原字母的本身；
第二位为离其最近的元音字母，如果与两个元音字母的距离相等，则选择离 a 这边最近的，不选离 z 这边近的；
第三位切换原字母的大小写。
请输出解密后的明文。

示例 1：
输入：
ac
输出：
acaC


#### 题解


##### 解法1: Python


```python

"""
@brief 字符串
"""

def main():
    # input
    s = str(input().strip())
    
    vowels = ['a', 'e', 'i', 'o', 'u']
    result = []
    
    for ch in s:
        if ch in vowels:
            result.append(ch)
        else:
            target = vowels[0]
            min_dist = abs(ord(ch) - ord(vowels[0]))
            for vowel in vowels[1:]:
                dist = abs(ord(ch) - ord(vowel))
                if dist < min_dist:
                    min_dist = dist
                    target = vowel
            # dist = [(abs(ord(ch) - ord(v)), v) for v in vowels]
            # target = min(dist)[1]
            # target = min(vowels, key=lambda v: (abs(ord(ch) - ord(v)), vowels.index(v)))
            result.append(ch + target + ch.upper())
    
    print(''.join(result))

if __name__ == "__main__":
    main()

```


---


<a id="删除公共字符"></a>

### 删除公共字符


知识点：字符串*****21

[参考-删除公共字符](https://www.nowcoder.com/practice/f0db4c36573d459cae44ac90b90c6212)


#### 题解


##### 解法1: Python


```python

"""
@brief 字符串
"""

import sys

def main():
    data = sys.stdin.read().splitlines()
    a = data[0].strip()
    b = data[1].strip()
        
    result = ''.join([ch for ch in a if ch not in b])
    print(result)

if __name__ == "__main__":
    main()

```


---


<a id="字符串表达式"></a>

### 字符串表达式


知识点：字符串、枚举（困难）****2

输入一个包含数字、加号、减号的字符串（可能仅有数字），要求删除一个字符，使得输出的结果最大。

示例 1：
输入：
2021
2021+2022-1
输出：
221
20212021


#### 题解


##### 解法1: Python


```python

"""
@brief eval
"""

def main():
    # input
    s = str(input().strip())
    n = len(s)

    max_result = float('-inf')
    
    for i in range(n):
        string = s[:i] + s[i+1:]
        try:
            result = eval(string)
            max_result = max(max_result, result)
        except:
            continue

    print(max_result)

if __name__ == "__main__":
    main()

```


##### 解法2: Python


```python

"""
@brief 贪心
"""

def calculate(expr):
    result = 0
    current_num = 0
    sign = 1  # 1表示正，-1表示负
    has_digit = False
    
    for ch in expr + '+':  # 加'+'方便处理最后一个数字
        if ch.isdigit():
            current_num = current_num * 10 + int(ch)
            has_digit = True
        else:  # 运算符
            if has_digit:
                result += sign * current_num
                current_num = 0
                has_digit = False
                sign = 1 if ch == '+' else -1
    
    return result

def main():
    # input
    s = str(input().strip())
    n = len(s)

    max_result = float('-inf')
    
    for i in range(n):
        string = s[:i] + s[i+1:]
        result = calculate(string)
        max_result = max(max_result, result)

    print(max_result)

if __name__ == "__main__":
    main()

```


---


<a id="数字位整除个数"></a>

### 数字位整除个数


知识点：字符串、贪心****22

一个正整数 n，判断 n 是否可以被 n 中的每个数整除，求可被整除的个数；

示例 1：  
输入：  
7300  
输出：  
0  

示例 2：  
输入：  
125  
输出：  
2


#### 题解


##### 解法1: Python


```python

"""
@brief 贪心
"""

def main():
    n = int(input().strip())
    s = str(n)
    
    count = 0
    for char in s:
        d = int(char)
        if d != 0 and n % d == 0:
            count += 1
    
    print(count)

if __name__ == "__main__":
    main()

```


---


<a id="查找敏感词"></a>

### 查找敏感词


知识点：滑动窗口*****2

[类似-敏感词](https://www.nowcoder.com/discuss/678023391353270272)

给定一个字符串数组，表示敏感词；再给定一个字符串，表示需要查找的文本。问文本中的敏感词一共有多少？

示例 1：
输入：
3
iakioi
ki
io
qwq
输出：
2

示例 2
输入：
1
aaa
aa
输出：
2


#### 题解


##### 解法1: Python


```python

"""
@brief 滑动窗口
"""

import sys

def s_count(text, pattern):
    count = 0
    start = 0
    while True:
        pos = text.find(pattern, start)
        if pos == -1:
            break
        count += 1
        start = pos + 1
    return count

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    a = str(data[1].strip())
    b = [str(data[i].strip()) for i in range(2, n+2)]
    
    total = 0
    for i in range(n):
        total += s_count(a, b[i])
    
    print(total)

if __name__ == "__main__":
    main()

```


---


<a id="字母和"></a>

### 字母和


知识点：集合、贪心*****17

已知大写字母 ASCII 值 'A'=65，给出一个字符串（只包含大写字母），求字符串中没有出现的字母 ASCII 值的和

示例 1：
输入：
ABBCDEF
输出：
1610


#### 题解


##### 解法1: Python


```python

"""
@brief set
"""

def main():
    # input
    s = str(input().strip())
    
    total = sum(range(65, 91))
    appeared = sum(ord(ch) for ch in set(s))

    result = total - appeared
    print(result)

if __name__ == "__main__":
    main()

```


##### 解法2: Python


```python

"""
@brief list
"""

def main():
    # input
    s = str(input().strip())
    
    appeared = [False] * 26
    for ch in s:
        appeared[ord(ch) - ord('A')] = True
    result = sum(ord('A') + i for i in range(26) if not appeared[i])

    print(result)

if __name__ == "__main__":
    main()

```


---


<a id="红黑数之和"></a>

### 红黑数之和


知识点：贪心、数学

输入n个整数的数组a，再输入n个字母的字符串s，s只包含'R'或'B'，si为'R'代表ai为红数，si为'B'代表ai为黑数，取一个红数与一个黑数相乘得到红黑数，问所有红黑数的和为多少？

输入：
第一行输入整数 n
第二行输入 n 个整数数组ai
第三行输入长度为 n 的字符串s
输出：
所有红黑数之和

示例 1：
输入：3
1 2 3
RBR
输出：8
说明：2*1+2*3=8

示例 2：
输入：
4
-1 2 -3 4
RBRB
输出：
-24


#### 题解


##### 解法1: Python


```python

""" 
@brief 贪心
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    a = list(map(int, data[1].split()))
    s = data[2].strip()
    
    red = 0
    black = 0
    
    for i in range(n):
        if s[i] == 'R':
            red += a[i]
        else:
            black += a[i]
    
    total = red * black

    print(total)

if __name__ == "__main__":
    main()

```


---


<a id="连续反转字符串"></a>

### 连续反转字符串


[原题-连续反转字符串](https://blog.csdn.net/bthbt/article/details/138012290)

知识点：双指针、队列、模拟*****4

输入一个长度为 n 的字符串，输入一个整数 k，依次按照 "i = 1, 2, ..., n-k+1" 的顺序操作字符串：将字符串的第 i 个字符至第 i+k-1 之间的所有字符翻转。

示例 1：
输入：
5 3
hello
输出：
lloeh
说明：
输入一个字符串长度 n=5 的字符串 "hello"，k=3  
i=1 对 [1, 3] 字符串反转，结果为 lehlo
i=2，对 [2, 4] 字符串反转，结果为 llheo
i=3,对 [3, 5] 字符串反转，结果为 lloeh
最终输出 lloeh


#### 题解


##### 解法1: Python


```python

"""
@brief 双指针
"""

import sys

def main():
    data = sys.stdin.read().splitlines()
    n, k = map(int, data[0].split())
    s = list(data[1].strip())

    for i in range(n - k + 1):
        # s[i:i+k] = s[i:i+k][::-1]
        left, right = i, i + k - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
    
    print(''.join(s))

if __name__ == "__main__":
    main()

```


---


<a id="相同子串个数"></a>

### 相同子串个数


知识点：贪心、滑动窗口、双指针（困难）*****10

- [原题-LYA的字符串收藏](https://www.nowcoder.com/discuss/660859777223819264)

一个字符串 s，截取连续 k 个相同的字母为子串，最多可以截多少个相同的子串？（子串之间不可重叠）

输入格式
第一行包含两个正整数 n 和 k，分别表示原字符串的长度和想要寻找字符串的长度。
第二行包含一个长度为 n 的字符串，仅由小写英文字母组成。
输出格式
输出一个整数，表示能找到的最大数量的互不重叠的长度为 k 的字符串。

示例 1
输入  
7 2
aabaacc
输出：  
2  

示例 2:
输入：
4 2
aaaa
输出：
2


#### 题解


##### 解法1: Python


```python

"""
@brief list
"""

import sys

def main():
    data = sys.stdin.read().splitlines()
    n, k = map(int, data[0].split())
    a = data[1].strip()
            
    count = [0] * 26
    i = 0
    while i <= n - k:
        if a[i:i+k] == a[i] * k:
            count[ord(a[i]) - ord('a')] += 1
            i += k
        else:
            i += 1

    print(max(count))

if __name__ == "__main__":
    main()

```


##### 解法2: Python


```python

"""
@brief dict
"""

import sys
from collections import defaultdict

def main():
    data = sys.stdin.read().splitlines()
    n, k = map(int, data[0].split())
    a = data[1].strip()
            
    count = defaultdict(int)
    i = 0
    while i <= n - k:
        if a[i:i+k] == a[i] * k:
            count[a[i]] += 1
            i += k
        else:
            i += 1

    result = max(count.values()) if count else 0
    print(result)

if __name__ == "__main__":
    main()

```


---


<a id="子串最小代价"></a>

### 子串最小代价


[acmer 子串代价](https://www.nowcoder.com/discuss/755539614802124800)

知识点：滑动窗口*****5

对于一个只包含英文字母的字符串，你可以更改其中的字符，不同的更改类型，代价如下：将一个字母改为另一个大小写相同的字母，花费为 5。将一个字母由大写改为小写或者由小写改为大写花费为 5。现在请你求出对于任给的一个只包含英文字母的字符串，使其中包含有子串 "AcMer" 的最小代价是多少？

示例 1：
输入  
AcAer
输出：  
5


#### 题解


##### 解法1: Python


```python

"""
@brief 滑动窗口
"""

def cost(c1, c2):
    a = 0 if c1.lower() == c2.lower() else 5
    b = 0 if c1.isupper() == c2.isupper() else 5
    return a + b

def main():
    # input
    s = str(input().strip())
    if n < len(t):
        print(-1)
        return
    
    t = "AcMer"
    n = len(s)
    min_cost = float('inf')

    for i in range(n - len(t) + 1):
        current = 0
        for j in range(len(t)):
            current += cost(s[i + j], t[j])
        min_cost = min(min_cost, current)

    # output
    print(min_cost)

if __name__ == "__main__":
    main()

```


---


<a id="大小写翻转"></a>

### 大小写翻转


知识点：贪心****23

一个由有 n 个大小写字母组成的字符串，每操作一次可使大小写字母翻转，如，A->a 或 a->A。要求，经过 k 次操作，使得字符串中的大写字母最多，并返回大写字母的个数。

示例 1：  
输入：  
1 3  
A
输出：  
0

示例 2：  
输入：  
5 3  
arBrg
输出：  
4


#### 题解


##### 解法1: Python


```python

"""
@brief manual
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n, k = map(int, data[0].split())
    s = str(data[1].strip())
    
    upper = sum(1 for c in s if c.isupper())
    lower = n - upper
    if k <= lower:
        result = upper + k
    else:
        result = n - ((k - lower) % 2)
    
    # output
    print(result)

if __name__ == "__main__":
    main()

```


---


<a id="数组"></a>

## 数组


<a id="数组加-1"></a>

### 数组加 1


知识点：数学****12

一个长度为 n，初始值为 0 的数组，输入 t 组 l, r, v，在区间 [l, r]，如果索引是 v 的倍数，则该索引对应的值 +1，输出最终数组。

示例 1：
输入：
5 2
1 4 1
1 5 2
输出：
1 2 1 2 0


#### 题解


##### 解法1: Python


```python

"""
@brief 数学
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n, t = map(int, data[0].split())
    a = [list(map(int, data[i].split())) for i in range(1, t+1)]
    
    arr = [0] * (n + 1)
    for i in range(t):
        l, r, v = a[i]
        start = v * ((l + v - 1) // v)
        for j in range(start, r + 1, v):
            arr[j] += 1

    result = " ".join(map(str, arr[1:]))
    print(result)

if __name__ == "__main__":
    main()

```


---


<a id="游戏记录"></a>

### 游戏记录


[参考-游戏记录](https://www.nowcoder.com/discuss/789506479857418240)

知识点：字典、排序****13

输入一个数 n，其后跟 n 行人名和游戏，表示这个人玩了哪些游戏，要求按人名和游戏名出现的先后顺序输出每个人玩的游戏

示例 1：
输入：
5
Alice Dota2
Bob LOL
Alice CSGO
Bob Dota2
Charlie CSGO
输出：
Alice: CSGO, Dota2
Bob: Dota2, LOL
Charlie: CSGO

示例 2：
输入：
4
Bob Football
Alice Basketball
Alice Basketball
Alice Basketball
输出：
Bob: Football
Alice: Basketball


#### 题解


##### 解法1: Python


```python

""" 
@brief 字典
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    name = [str(data[i].strip().split()[0]) for i in range(1, n+1)]
    game = [str(data[i].strip().split()[1]) for i in range(1, n+1)]
    
    result = {}
    for i in range(n):
        if name[i] in result:
            result[name[i]].add(game[i])
        else:
            result[name[i]] = set()
            result[name[i]].add(game[i])

    # output
    for name in result.keys():
        game = result[name]
        print(f"{name}: {', '.join(game)}")

if __name__ == "__main__":
    main()

```


---


<a id="非递减数组"></a>

### 非递减数组


知识点：贪心*****15

长度为 n 的数组，每次操作可以对一个数加 1，计算数组变为非递减数组的最小操作数

示例 1：
输入：
5
3 1 4 1 5
输出：
5


#### 题解


##### 解法1: Python


```python

"""
@brief 贪心
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    a = list(map(int, data[1].split()))
    
    count = 0
    for i in range(1, n):
        if a[i] < a[i-1]:
            count += a[i-1] - a[i]
            a[i] = a[i-1]
    
    print(count)

if __name__ == "__main__":
    main()

```


---


<a id="完美集合"></a>

### 完美集合


[参考-删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)
[参考-删除有序数组中的重复项2](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

知识点：贪心*****14

完美集合，集合内没有重复数字为完美集合，能够删除 k 次，求删除 k 次后能否构成完美集合。

示例 1：
输入：
6 3
1 2 2 3 3 3
输出：
Yes

示例 2：
输入：
8 2
1 2 2 3 3 3 4 5
输出：
No


#### 题解


##### 解法1: Python


```python

"""
@brief 贪心
"""

import sys
from collections import defaultdict

def main():
    # input
    data = sys.stdin.read().splitlines()
    n, k = map(int, data[0].split())
    arr = list(map(int, data[1].split()))

    freq = defaultdict(int)
    for num in arr:
        freq[num] += 1
    count = sum(freq[num]-1 for num in freq)
    # count = n - len(set(arr))
    result = "Yes" if count <= k else "No"
    
    print(result)

if __name__ == "__main__":
    main()

```


---


<a id="子数组除法"></a>

### 子数组除法


知识点：枚举（困难）****25

给一个数组 n，进行 k 段切割 (1 < k < n) 得到子数组，如果能找到 index 为 k-1 的子数组的和能整除 index 为 k 的子数组的和，则输出 "Yes"，否则输出 "No"

示例 1：
输入：
4 2
1 2 3 4
输出：
Yes

示例 2：
输入：
4 3
2 4 6 3
输出：
No

示例 3：
输入：
3 2
2 3 6
输出：
No


#### 题解


##### 解法1: Python


```python

"""
@brief 数组
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n, k = map(int, data[0].split())
    arr = list(map(int, data[1].split()))

    prefix = [0] * (n + 1)
    for i in range(n):
        prefix[i + 1] = prefix[i] + arr[i]
    
    for i in range(k - 1, n):
        a = prefix[n] - prefix[i]
        for j in range(max(k - 2, 0), i):
            if k == 2 and j != 0: 
                continue
            b = prefix[i] - prefix[j]
            if b != 0 and a % b == 0:
                print("Yes")
                return
    
    print("No")

if __name__ == "__main__":
    main()

```


---


<a id="数组相减相等"></a>

### 数组相减相等


知识点：数学*****25

给一个非负数组，每次取两个不同的数相减，结果替换其中一个数，可以重复无限次，求最终数组所有元素和的最小值。

示例 1
输入：
3
1 2 3
输出：
3


#### 题解


##### 解法1: Python


```python

"""
@brief 数学
"""

import sys

def my_gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    arr = list(map(int, data[1].split()))
    
    a = [x for x in arr if x > 0]
    if a:
        g = a[0]
        for i in range(1, len(a)):
            g = my_gcd(g, a[i])
    else:
        g = 0

    result = len(a) * g
    print(result)

if __name__ == "__main__":
    main()

```


---


<a id="排序"></a>

## 排序


<a id="字典序最大序列"></a>

### 字典序最大序列


[参考-构建字典序最大的可行序列](https://leetcode.cn/problems/construct-the-lexicographically-largest-valid-sequence/description/)

知识点：贪心、冒泡排序*****8

已知一个长度为 n 的序列由 1-n 中的数字组成，保证序列中每个元素各不相同，该序列中的数字可以进行如下操作：
与相邻的数字交换位置，每次交换，两个参与数字各消耗 1 次机会
已知每个数字最多有两次交换机会，输入最终得到的字典序最大的序列

输入：  
第一行 n  
第二行 n 个数代表初始序列  
输出：
字典序最大的序列号  

示例 1
输入：
5
1 2 3 4 5
输出：
3 4 1 2 5

示例 2：  
输入：  
6
1 2 6 5 4 3
输出：  
6 5 1 2 4 3


#### 题解


##### 解法1: Python


```python

"""
@brief 冒泡排序
"""

import sys

def main():
    data = sys.stdin.read().splitlines()    
    n = int(data[0])
    a = list(map(int, data[1].split()))

    count = [2] * (n + 1)
    for i in range(n):
        k = i
        for j in range(i + 1, min(i + 3, n)):
            if a[j] > a[k]:
                k = j
        
        while k > i and count[a[k]] > 0 and count[a[k-1]] > 0:
            a[k], a[k - 1] = a[k - 1], a[k]
            count[a[k]] -= 1
            count[a[k-1]] -= 1
            k -= 1

    print(*a)

if __name__ == "__main__":
    main()

```


---


<a id="最少交换次数"></a>

### 最少交换次数


[参考-逆序对](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5)

知识点：分治、排序、贪心、逆序对****20

给定数组 a,如果当前的 i+1 != a[i]，则需要交换（只能相邻进行交换）, 求最少的交换次数。

示例 1：
输入：
5
2 1 3 5 4  
输出：  
2


#### 题解


##### 解法1: Python


```python

"""
@brief enumerate
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    arr = list(map(int, data[1].split()))

    count = 0
    for i in range(n):
        for j in range(i + 1, n):
            if arr[i] > arr[j]:
                count += 1
    
    print(count)

if __name__ == "__main__":
    main()

```


##### 解法2: Python


```python

"""
@brief merge sort
"""

import sys

def merge_sort(arr):
    if len(arr) <= 1:
        return arr, 0
    mid = len(arr)//2
    left, a = merge_sort(arr[:mid])
    right, b = merge_sort(arr[mid:])

    i = j = 0
    c = 0
    result = []
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
            c += len(left) - i
    result.extend(left[i:])
    result.extend(right[j:])
    return result, a + b + c

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    arr = list(map(int, data[1].split()))

    _, count = merge_sort(arr)
    
    print(count)

if __name__ == "__main__":
    main()

```


---


<a id="数组删除"></a>

### 数组删除


知识点：数学、贪心、排序*****19

数组 n，随机取 i, j，如果 |n[i] - n[j]|<=1，删除大的那个值，求数组是否存在一种操作序列，使得最终数组只剩一个值

示例 1
输入：
4
1 2 2 3
输出：
Yes

示例 2
输入：
3
1 3 4
输出：
No


#### 题解


##### 解法1: Python


```python

"""
@brief 排序
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    arr = list(map(int, data[1].split()))
    
    arr.sort()
    for i in range(1, n):
        if arr[i] - arr[i-1] > 1:
            print("No")
            return

    print("Yes")

if __name__ == "__main__":
    main()

```


---


<a id="数组模排序"></a>

### 数组模排序


知识点：冒泡排序***

输入一个数组和一个连续区间，顺序遍历区间内每个数 k，然后顺序遍历数组，若 a[i] mod k > a[i+1] mod k，就交换 a[i] 和 a[i+1] 的数值。求遍历完区间，数组的最终序列。

输入：  
第一行输入 2 个数字 n m，n 代表数组长度，m 代表区间 [1, m]
第二行代表数组元素  

示例 1：
输入：
5 3
5 3 8 2 7
输出：
5 8 3 7 2


#### 题解


##### 解法1: Python


```python

""" 
@brief 冒泡排序
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n, m = list(map(int, data[0].split()))
    a = list(map(int, data[1].split()))
    
    # solve
    for k in range(1, m + 1):
        for i in range(n - 1):
            if a[i] % k > a[i + 1] % k:
                a[i], a[i + 1] = a[i + 1], a[i]
    
    # output
    print(" ".join(map(str, a)))

if __name__ == "__main__":
    main()

```


---


<a id="分数排序"></a>

### 分数排序


[参考-分数排序](https://blog.csdn.net/coutGavin/article/details/124720742)

知识点：排序

给定多组输入，每组两个数字，前面的代表分子，后面的代表分母，从小到大排序输出结果

示例 1：
输入：
4
4 7
3 8
1 2
-5 21    
输出：
-5 21
3 8
1 2
4 7


#### 题解


##### 解法1: Python


```python

""" 
@brief 排序
"""

import sys
from functools import cmp_to_key

def main():
    # read
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    arr = [tuple(map(int, data[i].split())) for i in range(1, n+1)]

    def compare(frac1, frac2):
        a, b = frac1
        c, d = frac2
        left = a * d
        right = b * c
        if left < right:
            return -1
        elif left > right:
            return 1
        else:
            return 0
    
    arr.sort(key=cmp_to_key(compare))

    for i in range(n):
        print(arr[i][0], arr[i][1])

if __name__ == "__main__":
    main()

```


---


<a id="双指针"></a>

## 双指针


<a id="字符串统计"></a>

### 字符串统计


知识点：枚举、双指针、滑动窗口***

一个字符串，求包括 'r'、'e' 同时不包括 'd' 的子串数量。

示例 1：
输入：
eredr
输出：
3


#### 题解


##### 解法1: Python


```python

""" 
@brief 双指针
"""

def main():
    # input
    s = input().strip()
    n = len(s)
    
    # solve
    count = 0
    for i in range(n):
        has_r = False
        has_e = False
        has_d = False
        for j in range(i, n):
            char = s[j]
            # check str
            if char == 'r':
                has_r = True
            elif char == 'e':
                has_e = True
            elif char == 'd':
                has_d = True
                break
            if has_r and has_e and not has_d:
                count += 1
    
    # output
    print(count)

if __name__ == "__main__":
    main()

```


##### 解法2: Python


```python

""" 
@brief 枚举
"""

def main():
    # input
    s = input().strip()
    n = len(s)
    
    # solve
    count = 0
    for i in range(n):
        for j in range(i, n):
            if 'd' in s[i:j+1]:
                continue
            if 'r' in s[i:j+1] and 'e' in s[i:j+1]:
                count += 1
    
    # output
    print(count)

if __name__ == "__main__":
    main()

```


---


<a id="对称数组"></a>

### 对称数组


[参考-对称数组](https://www.nowcoder.com/discuss/765942841079054336)

知识点：贪心、双指针****16

一个数组，一次可以对相邻 2 个数都加 +1，求将数组调整为对称数组的最小次数，如果无法调整为对称数组，返回 -1。

示例 1：  
输入：  
5  
1 1 2 2 1  
输出：  
1  
说明：将第二个元素和第三个元素加一即可,{1,1+1 2+1,2,1} -> {1,2,3,2,1}。


#### 题解


##### 解法1: Python


```python

"""
@brief 双指针
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    a = list(map(int, data[1].split()))

    count = 0
    left, right = 0, n - 1
    while left < right:
        diff = a[left] - a[right]
        if diff > 0:
            a[right] += diff
            a[right-1] += diff
            count += diff  
        elif diff < 0:
            a[left] += -diff
            a[left+1] += -diff
            count += -diff  
        left += 1
        right -= 1
    for i in range(n // 2):
        if a[i] != a[n - 1 - i]:
            count = -1
            break

    print(count)

if __name__ == "__main__":
    main()

```


---


<a id="模拟"></a>

## 模拟


<a id="打印里字"></a>

### 打印里字


知识点：模拟

[原题-打印里字](https://blog.csdn.net/huanbailu/article/details/142853525)

输入描述
一个正整数 n，代表"里”字的大小。1 <= n <= 30
输出描述
输出 11*n 行，每行输出一个长度为 11*n 的，仅包含'.'和'*'的字符串，这些'*'从视觉上组成了'里'字的形状

示例 1:
输入：
1
输出：
...........
..*******..
..*..*..*..
..*******..
..*..*..*..
..*******..
.....*.....
..*******..
.....*.....
.*********.
...........

示例 2:
输入：
2
输出：
......................
......................
....**************....
....**************....
....**....**....**....
....**....**....**....
....**************....
....**************....
....**....**....**....
....**....**....**....
....**************....
....**************....
..........**..........
..........**..........
....**************....
....**************....
..........**..........
..........**..........
..******************..
..******************..
......................
......................


#### 题解


##### 解法1: Python


```python

""" 
@brief 模拟
"""

def print_li(n):
    template = [
        "...........",  # 第0行
        "..*******..",  # 第1行
        "..*..*..*..",  # 第2行
        "..*******..",  # 第3行
        "..*..*..*..",  # 第4行
        "..*******..",  # 第5行
        ".....*.....",  # 第6行
        "..*******..",  # 第7行
        ".....*.....",  # 第8行
        ".*********.",  # 第9行
        "..........."   # 第10行
    ]
    result = []
    for line in template:
        expanded_line = "".join(char * n for char in line)
        for _ in range(n):
            result.append(expanded_line)
    
    return result

def main():
    # input
    n = int(input())

    output = print_li(n)
    for line in output:
        print(line)

if __name__ == "__main__":
    main()

```


---


<a id="贪吃蛇"></a>

### 贪吃蛇


[参考-贪吃蛇](https://blog.csdn.net/satur9/article/details/114419159)

知识点：字典、模拟****1

贪吃蛇只能上下左右移动，如果碰到边界停止不动。当贪吃蛇移动到食物上方则得一分，"A" 代表左移，"W" 代表上移，"S" 代表下移，"D" 代表右移。
第一行输入两个正整数 n 和 m，代表棋盘的行数和列数，接下来输入 n 行长度为 m 的字符串，代表棋盘。字符 "." 代表空地。字符 "*" 代表虫子。字符 "$" 代表食物。再输入只包含 "A"、"W"、"S"、"D" 的字符串代表操作。输出一个整数代表得分。

示例 1：
输入：
3 3 
...
.$.
.*.
WSDSA
输出：
1


#### 题解


##### 解法1: Python


```python

""" 
@brief 模拟
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    n, m = map(int, data[0].split())
    grid = [list(map(str, data[i].strip())) for i in range(1, n+1)]
    operations = str(data[n+1].strip())

    score = 0
    directions = {
        'W': (-1, 0),  # 上
        'S': (1, 0),   # 下
        'A': (0, -1),  # 左
        'D': (0, 1)    # 右
    }
    x, y = -1, -1
    for i in range(n):
        for j in range(m):
            if grid[i][j] == '*':
                x, y = i, j
                break
        if x != -1:
            break

    for op in operations:
        dx, dy = directions.get(op)
        nx, ny = x + dx, y + dy
        if 0 <= nx < n and 0 <= ny < m:
            x, y = nx, ny
            if grid[x][y] == '$':
                score += 1
                grid[x][y] = '.'

    print(score)

if __name__ == "__main__":
    main()

```


---


<a id="01-字符串截取"></a>

### 01 字符串截取


知识点：模拟

[参考-01字符串截取](https://blog.csdn.net/ouyang_peng/article/details/150503091)

一个字符串，只包含0，1，第 1 次截取开始 1 个，字符串去除截取的子串，第 2 次截取 2 个，以此类推，但长度达到 9 后，重新从 1 开始，当剩余字符不足当前截取长度时停止，输出每次截取子串的十进制数。

示例 1：  
输入：  
01001100  
输出：  
0 2 3


#### 题解


##### 解法1: Python


```python

""" 
@brief 模拟
"""

import sys

def main():
    # read
    data = sys.stdin.read().splitlines()
    s = data[0].strip()
    n = len(s)

    result = []
    step = 1
    index = 0

    while index + step <= n:
        sub = s[index:index + step]
        decimal = int(sub, 2)
        result.append(str(decimal))

        index += step
        step = (step % 9) + 1

    # output
    print(" ".join(result))

if __name__ == "__main__":
    main()

```


---


<a id="分治"></a>

## 分治


<a id="池化"></a>

### 池化


知识点：分治

输入n * n的矩阵（n确保为2的次幂且<=1024），矩阵中元素为整数，对矩阵不断做如下操作：  
将矩阵划分成若干个2*2大小的子矩阵，取出每个子矩阵中第二大的数字；  
将上一步取出的数字重新组成新的矩阵，并不断重复该操作直到最后剩余1个数字。  
输出最后剩余的数字  

示例 1：
输入:
4  
-6 -8 7 4  
-5 -5 14 11  
11 11 -1 -1  
4 9  -2 -4  
输出:  
11


#### 题解


##### 解法1: Python


```python

""" 
@brief 分治
"""

import sys

def main():
    # input
    data = sys.stdin.read().splitlines()
    n = int(data[0])
    matrix = [list(map(int, data[i].split())) for i in range(1, n+1)]
    
    # solve
    def solve(matrix):
        n = len(matrix)
        while n > 1:
            new_size = n // 2
            new_matrix = [[0] * new_size for _ in range(new_size)]
            
            for i in range(0, n, 2):
                for j in range(0, n, 2):
                    nums = [
                        matrix[i][j], matrix[i][j+1],
                        matrix[i+1][j], matrix[i+1][j+1]
                    ]
                    new_matrix[i//2][j//2] = sorted(nums)[-2]
            matrix = new_matrix
            n = new_size
        
        return matrix[0][0]
    
    result = solve(matrix)

    # output
    print(result)

if __name__ == "__main__":
    main()

```


---

